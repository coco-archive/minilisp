* 6809 assembly program generated by cmoc 0.1.35
	ORG	$1480		Code section
program_start	EQU	*
	LBSR	INILIB		initialize standard library and global variables
	LBSR	_main		call main()
	PSHS	B,A		send main() return value to exit()
	LBSR	_exit		use LBSR to respect calling convention
functions_start	EQU	*


*******************************************************************************

* FUNCTION acons(): defined at minilisp.c:382
_acons	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-10,S	
* Line minilisp.c:383: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:382
* optim: remove16BitStackOperation
	LEAX	-8,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:383: for init
* Line minilisp.c:383: init of variable i
	CLRA
	LDB	#$01		1
	STD	-10,U		variable i
	BRA	L00316		jump to for condition
L00315	EQU	*
* Line minilisp.c:383: for body
* Line minilisp.c:383: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-8,U		address of array root_ADD_ROOT_
	LDD	-10,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:383: for increment(s)
	LDD	-10,U	
	ADDD	#1	
	STD	-10,U	
L00316	EQU	*
* Line minilisp.c:383: for condition
	LDD	-10,U		variable i
	CMPD	#$01	
	BLE	L00315	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:383: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-4,U		index 2 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:383: assignment: =
	LEAX	-8,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:383: init of variable cell
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable cell
* Line minilisp.c:384: assignment: =
* Line minilisp.c:384: function call: cons()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:382
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_cons	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable cell
* 
	STD	,X	
* Line minilisp.c:385: return with value
* Line minilisp.c:385: function call: cons()
	LDY	10,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-2,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:382
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_cons	
	LEAS	6,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION add_primitive(): defined at minilisp.c:1143
_add_primitive	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-14,S	
* Line minilisp.c:1144: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:1143
* optim: remove16BitStackOperation
	LEAX	-12,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1144: for init
* Line minilisp.c:1144: init of variable i
	CLRA
	LDB	#$01		1
	STD	-14,U		variable i
	BRA	L00320		jump to for condition
L00319	EQU	*
* Line minilisp.c:1144: for body
* Line minilisp.c:1144: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-12,U		address of array root_ADD_ROOT_
	LDD	-14,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:1144: for increment(s)
	LDD	-14,U	
	ADDD	#1	
	STD	-14,U	
L00320	EQU	*
* Line minilisp.c:1144: for condition
	LDD	-14,U		variable i
	CMPD	#$02	
	BLE	L00319	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:1144: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-6,U		index 3 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1144: assignment: =
	LEAX	-12,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:1144: init of variable sym
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable sym
* Line minilisp.c:1144: init of variable prim
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable prim
* Line minilisp.c:1145: assignment: =
* Line minilisp.c:1145: function call: intern()
	LDX	8,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1143
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_intern	
	LEAS	4,S	
* optim: pushDLoadXLoadD
	LDX	-4,U		indirection of variable sym
* 
	STD	,X	
* Line minilisp.c:1146: assignment: =
* Line minilisp.c:1146: function call: make_primitive()
	LDX	10,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1143
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_make_primitive
	LEAS	4,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable prim
* 
	STD	,X	
* Line minilisp.c:1147: function call: add_variable()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1143
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_add_variable
	LEAS	8,S	
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION add_variable(): defined at minilisp.c:719
_add_variable	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-16,S	
* Line minilisp.c:721: init of variable bind
* Line minilisp.c:721: function call: find()
	LDX	8,U		indirection of variable sym
	LDX	,X		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:719
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_find	
	LEAS	4,S	
	STD	-14,U		variable bind
* Line minilisp.c:722: if
* optim: storeLoad
	ADDD	#0	
	BEQ	L00324	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:723: assignment: =
* optim: optimizeIndexedX
	LDD	[10,U]		optim: optimizeIndexedX
* optim: remove16BitStackOperation
	LDX	-14,U		variable bind
	LEAX	4,X		member val of Obj
	LEAX	2,X		member cdr of cell
* optim: remove16BitStackOperation
	STD	,X	
	LBRA	L00136		return (minilisp.c:724)
L00324	EQU	*		else
* Useless label removed
* Line minilisp.c:727: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:719
* optim: remove16BitStackOperation
	LEAX	-12,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:727: for init
* Line minilisp.c:727: init of variable i
	CLRA
	LDB	#$01		1
	STD	-16,U		variable i
	BRA	L00327		jump to for condition
L00326	EQU	*
* Line minilisp.c:727: for body
* Line minilisp.c:727: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-12,U		address of array root_ADD_ROOT_
	LDD	-16,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:727: for increment(s)
	LDD	-16,U	
	ADDD	#1	
	STD	-16,U	
L00327	EQU	*
* Line minilisp.c:727: for condition
	LDD	-16,U		variable i
	CMPD	#$02	
	BLE	L00326	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:727: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-6,U		index 3 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:727: assignment: =
	LEAX	-12,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:727: init of variable vars
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable vars
* Line minilisp.c:727: init of variable tmp
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable tmp
* Line minilisp.c:728: assignment: =
* optim: optimizeIndexedX
	LDD	[6,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member vars of env
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable vars
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:729: assignment: =
* Line minilisp.c:729: function call: acons()
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	10,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	8,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:719
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_acons	
	LEAS	8,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable tmp
* 
	STD	,X	
* Line minilisp.c:730: assignment: =
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[6,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,S++	
	STD	,X	
L00136	EQU	*		end of add_variable()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION advanceOffset(): defined at /usr/local/share/cmoc/disk.h:442
_advanceOffset	EQU	*
	PSHS	U	
	LEAU	,S	
* Line /usr/local/share/cmoc/disk.h:444: function call: adddww()
	LDD	6,U		variable numBytes, declared at /usr/local/share/cmoc/disk.h:442
	PSHS	B,A		argument 2 of adddww()
	LDX	4,U		variable fd
	LEAX	12,X		member offset of FileDesc
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_adddww	
	LEAS	4,S	
* Line /usr/local/share/cmoc/disk.h:445: assignment: +=
* optim: optimize16BitStackOps1
* optim: optimize16BitStackOps1
	LDX	4,U		variable fd
	LEAX	16,X		member secOffset of FileDesc
	LDD	,X	
	ADDD	6,U		optim: optimize16BitStackOps1
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:448: do-while
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:448: if
	LDX	4,U		variable fd
	LDD	274,X		member curSectorAvailBytes of FileDesc
	PSHS	B,A	
* optim: removeUselessLdx
	LDD	16,X		member secOffset of FileDesc
	CMPD	,S++	
	BLS	L00334	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:448: function call: printf()
	LEAX	S00220,PCR	"fd->secOffset <= fd->curSectorAvailBytes"
* optim: optimizePshsOps
	LDD	#$01C0		decimal 448 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAY	S00212,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	S00211,PCR	"***ASSERT FAILED: %s:%u: %s\n"
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_printf	
	LEAS	8,S	
L00336	EQU	*
* Line /usr/local/share/cmoc/disk.h:448: for body
* Useless label removed
	BRA	L00336	
* Useless label removed
L00334	EQU	*		else
* Useless label removed
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:450: if
	LDX	4,U		variable fd
	LDD	274,X		member curSectorAvailBytes of FileDesc
	PSHS	B,A	
* optim: removeUselessLdx
	LDD	16,X		member secOffset of FileDesc
	CMPD	,S++	
	BLO	L00341	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:455: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable fd
	LEAX	16,X		member secOffset of FileDesc
	LDB	#0		optim: removeAndOrMulAddSub
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:456: assignment: =
* optim: removeClr
* optim: removeClr
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable fd
	LEAX	274,X		member curSectorAvailBytes of FileDesc
	LDB	#0		optim: removeAndOrMulAddSub
	STD	,X	
L00341	EQU	*		else
* Useless label removed
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION alloc(): defined at minilisp.c:197
_alloc	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:203: assignment: +=
	CLRA
	CLRB
	TFR	D,X		X points to a struct Obj
	LDX	#$4		optim: removeAndOrMulAddSub
	TFR	X,D		address-of operator
	ADDD	8,U		optim: pushDLoadAdd
* 
* 
	STD	8,U	
* Line minilisp.c:208: assignment: =
* Line minilisp.c:208: function call: roundup()
	LDX	#$02		optim: transformPshsDPshsD
	PSHS	X		optim: transformPshsDPshsD
* optim: removeUselessLdd
	PSHS	B,A		argument 1 of roundup()
	LBSR	_roundup
	LEAS	4,S	
	STD	8,U	
* Line minilisp.c:215: if
	LDB	G00199+0,PCR	variable always_gc, declared at minilisp.c:135
* optim: loadCmpZeroBeqOrBne
	BEQ	L00344	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	G00197+0,PCR	variable gc_running, declared at minilisp.c:133
* optim: loadCmpZeroBeqOrBne
	BNE	L00344	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:216: function call: gc()
	LDD	4,U		variable root, declared at minilisp.c:197
	PSHS	B,A		argument 1 of gc()
	LBSR	_gc	
	LEAS	2,S	
L00344	EQU	*		else
* Useless label removed
* Line minilisp.c:219: if
	LDB	G00199+0,PCR	variable always_gc, declared at minilisp.c:135
* optim: loadCmpZeroBeqOrBne
	BNE	L00348	
* optim: branchToNextLocation
* Useless label removed
* optim: optimize16BitStackOps1
* optim: optimize16BitStackOps1
	LDD	G00196+0,PCR	variable mem_nused, declared at minilisp.c:130
	ADDD	8,U		optim: optimize16BitStackOps1
	PSHS	B,A	
	LDD	#$1080		decimal 4224 signed
	CMPD	,S++	
	BHS	L00348	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:220: function call: gc()
	LDD	4,U		variable root, declared at minilisp.c:197
	PSHS	B,A		argument 1 of gc()
	LBSR	_gc	
	LEAS	2,S	
L00348	EQU	*		else
* Useless label removed
* Line minilisp.c:224: if
* optim: optimize16BitStackOps1
* optim: optimize16BitStackOps1
	LDD	G00196+0,PCR	variable mem_nused, declared at minilisp.c:130
	ADDD	8,U		optim: optimize16BitStackOps1
	PSHS	B,A	
	LDD	#$1080		decimal 4224 signed
	CMPD	,S++	
	BHS	L00352	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:225: function call: printf()
* optim: optimize16BitStackOps2
* optim: optimize16BitStackOps2
	LDD	G00196+0,PCR	variable mem_nused, declared at minilisp.c:130
	ADDD	8,U		optim: optimize16BitStackOps2
	PSHS	B,A		argument 3 of printf()
	LDD	#$1080		decimal 4224 signed
	PSHS	B,A		argument 2 of printf()
	LEAX	S00221,PCR	"MEMORY EXHAUSTED %x < %x\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	6,S	
* Line minilisp.c:225: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00352	EQU	*		else
* Useless label removed
* Line minilisp.c:228: init of variable obj
	LDD	G00196+0,PCR	variable mem_nused, declared at minilisp.c:130
	ADDD	G00194+0,PCR	optim: pushDLoadAdd
* 
* 
	STD	-2,U		variable obj
* Line minilisp.c:229: assignment: =
	LDD	6,U		variable type, declared at minilisp.c:197
* optim: remove16BitStackOperation
	LDX	-2,U		variable obj
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:230: assignment: =
	LDD	8,U		variable size, declared at minilisp.c:197
* optim: remove16BitStackOperation
	LDX	-2,U		variable obj
	LEAX	2,X		member size of Obj
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:231: assignment: +=
	LDD	G00196+0,PCR	variable mem_nused
	ADDD	8,U		variable size
	STD	G00196+0,PCR	variable mem_nused
* Line minilisp.c:232: return with value
	LDD	-2,U		variable obj, declared at minilisp.c:228
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION apply(): defined at minilisp.c:785
_apply	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-10,S	
* Line minilisp.c:786: if
* Line minilisp.c:786: function call: is_list()
	LDX	10,U		indirection of variable args
	LDD	,X		indirection
	PSHS	B,A		argument 1 of is_list()
	LBSR	_is_list
	LEAS	2,S	
	TSTB
	BNE	L00355	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:787: function call: printf()
	LEAX	S00249,PCR	"ARGUMENT MUST BE A LIST\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:787: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00355	EQU	*		else
* Useless label removed
* Line minilisp.c:788: if
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BNE	L00358	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:789: return with value
* Line minilisp.c:789: function call through pointer
	LDY	10,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:785
	PSHS	X,B,A		optim: optimizePshsOps
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member fn of val
	TFR	D,X	
	JSR	,X	
	LEAS	6,S	
	LBRA	L00142		return (minilisp.c:789)
L00358	EQU	*		else
* Useless label removed
* Line minilisp.c:790: if
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	LBNE	L00361	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:791: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:785
* optim: remove16BitStackOperation
	LEAX	-8,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:791: for init
* Line minilisp.c:791: init of variable i
	CLRA
	LDB	#$01		1
	STD	-10,U		variable i
	BRA	L00364		jump to for condition
L00363	EQU	*
* Line minilisp.c:791: for body
* Line minilisp.c:791: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-8,U		address of array root_ADD_ROOT_
	LDD	-10,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:791: for increment(s)
	LDD	-10,U	
	ADDD	#1	
	STD	-10,U	
L00364	EQU	*
* Line minilisp.c:791: for condition
	LDD	-10,U		variable i
	CMPD	#$01	
	BLE	L00363	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:791: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-4,U		index 2 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:791: assignment: =
	LEAX	-8,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:791: init of variable eargs
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable eargs
* Line minilisp.c:792: assignment: =
* Line minilisp.c:792: function call: eval_list()
	LDY	10,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:785
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable eargs
* 
	STD	,X	
* Line minilisp.c:793: return with value
* Line minilisp.c:793: function call: apply_func()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:785
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_apply_func
	LEAS	8,S	
	BRA	L00142		return (minilisp.c:793)
L00361	EQU	*		else
* Useless label removed
* Line minilisp.c:795: function call: printf()
	LEAX	S00250,PCR	"NOT SUPPORTED\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:795: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00142	EQU	*		end of apply()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION apply_func(): defined at minilisp.c:775
_apply_func	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-18,S	
* Line minilisp.c:776: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:775
* optim: remove16BitStackOperation
	LEAX	-16,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:776: for init
* Line minilisp.c:776: init of variable i
	CLRA
	LDB	#$01		1
	STD	-18,U		variable i
	BRA	L00368		jump to for condition
L00367	EQU	*
* Line minilisp.c:776: for body
* Line minilisp.c:776: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-16,U		address of array root_ADD_ROOT_
	LDD	-18,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:776: for increment(s)
	LDD	-18,U	
	ADDD	#1	
	STD	-18,U	
L00368	EQU	*
* Line minilisp.c:776: for condition
	LDD	-18,U		variable i
	CMPD	#$03	
	BLE	L00367	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:776: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-8,U		index 4 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:776: assignment: =
	LEAX	-16,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:776: init of variable params
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-6,U		variable params
* Line minilisp.c:776: init of variable newenv
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable newenv
* Line minilisp.c:776: init of variable body
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable body
* Line minilisp.c:777: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member params of func
* optim: remove16BitStackOperation
	LDX	-6,U		indirection of variable params
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:778: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	4,X		member env of func
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable newenv
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:779: assignment: =
* Line minilisp.c:779: function call: push_env()
	LDY	10,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	-6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-4,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:775
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_push_env
	LEAS	8,S	
* optim: pushDLoadXLoadD
	LDX	-4,U		indirection of variable newenv
* 
	STD	,X	
* Line minilisp.c:780: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member body of func
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable body
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:781: return with value
* Line minilisp.c:781: function call: progn()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-4,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:775
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_progn	
	LEAS	6,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION ascii2screen(): defined at minilisp.c:414
_ascii2screen	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:415: if
	LDB	5,U		variable c
	CMPB	#$61	
	BLT	L00372	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	5,U		variable c
	CMPB	#$7A	
	BGT	L00372	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:416: return with value
	LDB	5,U	
	SEX
	ADDD	#$FFA0		65440
	BRA	L00117		return (minilisp.c:416)
L00372	EQU	*		else
* Useless label removed
* Line minilisp.c:418: if
	LDB	5,U		variable c
	CMPB	#$20	
	BLT	L00376	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	5,U		variable c
	CMPB	#$3F	
	BGT	L00376	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:419: return with value
	LDB	5,U	
	SEX
	ADDD	#$40		64
	BRA	L00117		return (minilisp.c:419)
L00376	EQU	*		else
* Useless label removed
* Line minilisp.c:421: return with value
	LDB	5,U		variable c, declared at minilisp.c:414
* optim: branchToNextLocation
L00117	EQU	*		end of ascii2screen()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION close(): defined at /usr/local/share/cmoc/disk.h:244
_close	EQU	*
	PSHS	U	
	LEAU	,S	
* Line /usr/local/share/cmoc/disk.h:246: return with value
	CLRA
	CLRB
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION computeFileLength(): defined at /usr/local/share/cmoc/disk.h:570
_computeFileLength	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-5,S	
* Line /usr/local/share/cmoc/disk.h:572: if
	LDD	4,U		variable dwLength, declared at /usr/local/share/cmoc/disk.h:570
* optim: loadCmpZeroBeqOrBne
	BNE	L00380	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:573: return with value
	CLRA
	CLRB
	LBRA	L00091		return (/usr/local/share/cmoc/disk.h:573)
L00380	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:576: assignment: =
* LDD #$FFFF optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		get pointer value
	LDD	#65535		optim: optimizeStackOperations1
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:577: assignment: =
* LDD #$FFFF optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		get pointer value
	LEAX	2,X		add index (1) multiplied by pointed object size (2)
	LDD	#65535		optim: optimizeStackOperations1
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:579: if
	LDB	7,U		variable firstGran
	CMPB	#$43	
	BLS	L00383	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:580: return with value
	CLRA
	CLRB
	LBRA	L00091		return (/usr/local/share/cmoc/disk.h:580)
L00383	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:581: if
	LDD	8,U		variable numBytesLastSector
	CMPD	#$0100	
	BLS	L00386	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:582: return with value
	CLRA
	CLRB
	LBRA	L00091		return (/usr/local/share/cmoc/disk.h:582)
L00386	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:584: init of variable fat
* Line /usr/local/share/cmoc/disk.h:584: function call: updateFAT()
	LBSR	_updateFAT
	STD	-5,U		variable fat
* Line /usr/local/share/cmoc/disk.h:585: if
* optim: storeLoad
	ADDD	#0	
	BNE	L00389	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:586: return with value
	CLRA
	CLRB
	LBRA	L00091		return (/usr/local/share/cmoc/disk.h:586)
L00389	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:588: init of variable curGran
	LDX	-5,U		pointer fat
	LDB	7,U		variable firstGran
	CLRA			index expression is of byte type
	ABX			optim: removeAndOrMulAddSub
	LDB	,X		get r-value
	STB	-3,U		variable curGran
* Line /usr/local/share/cmoc/disk.h:589: function call: zerodw()
	LDD	4,U		variable dwLength, declared at /usr/local/share/cmoc/disk.h:570
	PSHS	B,A		argument 1 of zerodw()
	LBSR	_zerodw	
	LEAS	2,S	
* Line /usr/local/share/cmoc/disk.h:590: while
L00392	EQU	*		while condition at /usr/local/share/cmoc/disk.h:590
	LDB	-3,U		variable curGran
	CMPB	#$C0	
	BHI	L00393	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:592: function call: adddww()
	LDX	#$0900		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable dwLength, declared at /usr/local/share/cmoc/disk.h:570
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_adddww	
	LEAS	4,S	
* Line /usr/local/share/cmoc/disk.h:593: assignment: =
	LDX	-5,U		pointer fat
	LDB	-3,U		variable curGran
	CLRA			index expression is of byte type
	ABX			optim: removeAndOrMulAddSub
	LDB	,X		get r-value
	STB	-3,U	
	BRA	L00392		go to while condition
L00393	EQU	*		after end of while starting at /usr/local/share/cmoc/disk.h:590
* Line /usr/local/share/cmoc/disk.h:596: init of variable numBytesLastGran
	LDB	-3,U	
	CLRA
	ADDB	#$3F		optim: changeAddDToAddB
* optim: stripExtraClrA_B
	STD	-2,U		variable numBytesLastGran
* optim: storeLoad
	EXG	A,B		/usr/local/share/cmoc/disk.h:598: [inline asm]
	STD	-2,U		/usr/local/share/cmoc/disk.h:599: [inline asm] re: variable numBytesLastGran
* Line /usr/local/share/cmoc/disk.h:600: assignment: +=
* optim: storeLoad
	ADDD	8,U		variable numBytesLastSector
	STD	-2,U		variable numBytesLastGran
* Line /usr/local/share/cmoc/disk.h:602: function call: adddww()
* optim: storeLoad
	PSHS	B,A		argument 2 of adddww()
	LDD	4,U		variable dwLength, declared at /usr/local/share/cmoc/disk.h:570
	PSHS	B,A		argument 1 of adddww()
	LBSR	_adddww	
	LEAS	4,S	
* Line /usr/local/share/cmoc/disk.h:604: return with value
	CLRA
	LDB	#$01		decimal 1 signed
* optim: branchToNextLocation
L00091	EQU	*		end of computeFileLength()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION cons(): defined at minilisp.c:346
_cons	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:347: init of variable cell
* Line minilisp.c:347: function call: alloc()
	LDY	#$04		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	#$02		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:346
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_alloc	
	LEAS	6,S	
	STD	-2,U		variable cell
* Line minilisp.c:348: assignment: =
* optim: optimizeIndexedX
	LDD	[6,U]		optim: optimizeIndexedX
* optim: remove16BitStackOperation
	LDX	-2,U		variable cell
	LEAX	4,X		member val of Obj
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:349: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
* optim: remove16BitStackOperation
	LDX	-2,U		variable cell
	LEAX	4,X		member val of Obj
	LEAX	2,X		member cdr of cell
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:350: return with value
	LDD	-2,U		variable cell, declared at minilisp.c:347
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION define_constants(): defined at minilisp.c:1150
_define_constants	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-10,S	
* Line minilisp.c:1151: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:1150
* optim: remove16BitStackOperation
	LEAX	-8,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1151: for init
* Line minilisp.c:1151: init of variable i
	CLRA
	LDB	#$01		1
	STD	-10,U		variable i
	BRA	L00395		jump to for condition
L00394	EQU	*
* Line minilisp.c:1151: for body
* Line minilisp.c:1151: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-8,U		address of array root_ADD_ROOT_
	LDD	-10,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:1151: for increment(s)
	LDD	-10,U	
	ADDD	#1	
	STD	-10,U	
L00395	EQU	*
* Line minilisp.c:1151: for condition
	LDD	-10,U		variable i
	CMPD	#$01	
	BLE	L00394	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:1151: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-4,U		index 2 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1151: assignment: =
	LEAX	-8,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:1151: init of variable sym
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable sym
* Line minilisp.c:1152: assignment: =
* Line minilisp.c:1152: function call: intern()
	LEAX	S00245,PCR	"T"
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1150
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_intern	
	LEAS	4,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable sym
* 
	STD	,X	
* Line minilisp.c:1153: function call: add_variable()
	LEAX	G00187+0,PCR	variable True, declared at minilisp.c:105
* optim: optimizePshsOps
	LDD	-2,U		variable sym, declared at minilisp.c:1151
	PSHS	X,B,A		optim: optimizePshsOps
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1150
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_add_variable
	LEAS	8,S	
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION define_primitives(): defined at minilisp.c:1179
_define_primitives	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:1180: function call: add_primitive()
	LEAX	_prim_quote,PCR	address of prim_quote(), defined at minilisp.c:863
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00232,PCR	"QUOTE"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1181: function call: add_primitive()
	LEAX	_prim_cons,PCR	address of prim_cons(), defined at minilisp.c:870
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00285,PCR	"CONS"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1182: function call: add_primitive()
	LEAX	_prim_car,PCR	address of prim_car(), defined at minilisp.c:879
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00286,PCR	"CAR"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1183: function call: add_primitive()
	LEAX	_prim_cdr,PCR	address of prim_cdr(), defined at minilisp.c:887
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00287,PCR	"CDR"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1184: function call: add_primitive()
	LEAX	_prim_setq,PCR	address of prim_setq(), defined at minilisp.c:895
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00288,PCR	"SETQ"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1185: function call: add_primitive()
	LEAX	_prim_setcar,PCR	address of prim_setcar(), defined at minilisp.c:909
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00289,PCR	"SETCAR"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1186: function call: add_primitive()
	LEAX	_prim_while,PCR	address of prim_while(), defined at minilisp.c:919
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00290,PCR	"WHILE"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1187: function call: add_primitive()
	LEAX	_prim_gensym,PCR	address of prim_gensym(), defined at minilisp.c:932
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00291,PCR	"GENSYM"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1188: function call: add_primitive()
	LEAX	_prim_plus,PCR	address of prim_plus(), defined at minilisp.c:940
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00292,PCR	"+"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1189: function call: add_primitive()
	LEAX	_prim_mult,PCR	address of prim_mult(), defined at minilisp.c:952
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00293,PCR	"*"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1190: function call: add_primitive()
	LEAX	_prim_minus,PCR	address of prim_minus(), defined at minilisp.c:964
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00294,PCR	"-"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1191: function call: add_primitive()
	LEAX	_prim_lt,PCR	address of prim_lt(), defined at minilisp.c:978
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00295,PCR	"<"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1192: function call: add_primitive()
	LEAX	_prim_define,PCR	address of prim_define(), defined at minilisp.c:1026
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00296,PCR	"DEFINE"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1193: function call: add_primitive()
	LEAX	_prim_defun,PCR	address of prim_defun(), defined at minilisp.c:1021
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00297,PCR	"DEFUN"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1194: function call: add_primitive()
	LEAX	_prim_defmacro,PCR	address of prim_defmacro(), defined at minilisp.c:1038
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00298,PCR	"DEFMACRO"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1195: function call: add_primitive()
	LEAX	_prim_macroexpand,PCR	address of prim_macroexpand(), defined at minilisp.c:1043
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00299,PCR	"MACROEXPAND"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1196: function call: add_primitive()
	LEAX	_prim_lambda,PCR	address of prim_lambda(), defined at minilisp.c:1005
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00300,PCR	"LAMBDA"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1197: function call: add_primitive()
	LEAX	_prim_if,PCR	address of prim_if(), defined at minilisp.c:1061
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00301,PCR	"IF"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1198: function call: add_primitive()
	LEAX	_prim_num_eq,PCR	address of prim_num_eq(), defined at minilisp.c:1076
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00302,PCR	"="
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1199: function call: add_primitive()
	LEAX	_prim_num_lt,PCR	address of prim_num_lt(), defined at minilisp.c:1088
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00295,PCR	"<"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1200: function call: add_primitive()
	LEAX	_prim_num_gt,PCR	address of prim_num_gt(), defined at minilisp.c:1100
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00303,PCR	">"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1201: function call: add_primitive()
	LEAX	_prim_num_lte,PCR	address of prim_num_lte(), defined at minilisp.c:1112
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00304,PCR	"<="
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1202: function call: add_primitive()
	LEAX	_prim_num_gte,PCR	address of prim_num_gte(), defined at minilisp.c:1124
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00305,PCR	">="
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1203: function call: add_primitive()
	LEAX	_prim_eq,PCR	address of prim_eq(), defined at minilisp.c:1136
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00306,PCR	"EQ"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1204: function call: add_primitive()
	LEAX	_prim_println,PCR	address of prim_println(), defined at minilisp.c:1052
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00307,PCR	"PRINTLN"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Line minilisp.c:1205: function call: add_primitive()
	LEAX	_prim_load,PCR	address of prim_load(), defined at minilisp.c:1158
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00308,PCR	"LOAD"
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:1179
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1179
	PSHS	B,A		argument 1 of add_primitive()
	LBSR	_add_primitive
	LEAS	8,S	
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION dskcon(): defined at /usr/local/share/cmoc/disk.h:39
_dskcon	EQU	*
	PSHS	U	
	LEAU	,S	
* Line /usr/local/share/cmoc/disk.h:42: if
	LDB	5,U		variable operation
	CMPB	#$02	
	BEQ	L00399	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	5,U		variable operation
	CMPB	#$03	
	BEQ	L00399	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:43: return with value
	CLRA
	CLRB
	LBRA	L00075		return (/usr/local/share/cmoc/disk.h:43)
L00399	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:44: if
	LDD	6,U		variable buffer, declared at /usr/local/share/cmoc/disk.h:39
* optim: loadCmpZeroBeqOrBne
	BNE	L00403	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:45: return with value
	CLRA
	CLRB
	LBRA	L00075		return (/usr/local/share/cmoc/disk.h:45)
L00403	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:46: if
	LDB	9,U		variable drive
	CMPB	#$04	
	BLO	L00406	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:47: return with value
	CLRA
	CLRB
	LBRA	L00075		return (/usr/local/share/cmoc/disk.h:47)
L00406	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:48: if
	LDB	11,U		variable track
	CMPB	#$23	
	BLO	L00409	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:49: return with value
	CLRA
	CLRB
	LBRA	L00075		return (/usr/local/share/cmoc/disk.h:49)
L00409	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:50: if
	LDB	13,U		variable sector, declared at /usr/local/share/cmoc/disk.h:39
* optim: loadCmpZeroBeqOrBne
	BNE	L00412	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:51: return with value
	CLRA
	CLRB
	BRA	L00075		return (/usr/local/share/cmoc/disk.h:51)
L00412	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:52: if
	LDB	13,U		variable sector
	CMPB	#$12	
	BLS	L00415	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:53: return with value
	CLRA
	CLRB
	BRA	L00075		return (/usr/local/share/cmoc/disk.h:53)
L00415	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:56: assignment: =
	LDB	5,U	
	STB	$EA	
* Line /usr/local/share/cmoc/disk.h:57: assignment: =
	LDB	9,U	
	STB	$EB	
* Line /usr/local/share/cmoc/disk.h:58: assignment: =
	LDB	11,U	
	STB	$EC	
* Line /usr/local/share/cmoc/disk.h:59: assignment: =
	LDB	13,U	
	STB	$ED	
* Line /usr/local/share/cmoc/disk.h:60: assignment: =
	LDD	6,U	
	STD	$EE	
	PSHS	U,Y,X,A		/usr/local/share/cmoc/disk.h:62: [inline asm]
	JSR	[$C004]		/usr/local/share/cmoc/disk.h:63: [inline asm]
	PULS	A,X,Y,U		/usr/local/share/cmoc/disk.h:64: [inline asm]
* Line /usr/local/share/cmoc/disk.h:66: return with value
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LDB	$F0		decimal 240
* optim: stripExtraClrA_B
	CMPD	#0		optim: optimizeStackOperations1
	BEQ	L00417		if true
	CLRB
	BRA	L00418		false
L00417	EQU	*
	LDB	#1	
L00418	EQU	*
* optim: branchToNextLocation
L00075	EQU	*		end of dskcon()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION eval(): defined at minilisp.c:824
_eval	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-18,S	
* Line minilisp.c:825: switch
* optim: optimizeIndexedX
	LDX	[8,U]		optim: removeTfrDX
* optim: removeTfrDX
	LDD	,X		member type of Obj
	CMPD	#$01		case 1
	BEQ	L00420	
	CMPD	#$04		case 4
	BEQ	L00421	
	CMPD	#$05		case 5
	BEQ	L00422	
	CMPD	#$09		case 9
	BEQ	L00423	
	CMPD	#$0A		case 10
	BEQ	L00424	
	CMPD	#$03		case 3
	BEQ	L00425	
	CMPD	#$02		case 2
	LBEQ	L00426	
	LBRA	L00427		switch default
L00420	EQU	*		case 1
L00421	EQU	*		case 4
L00422	EQU	*		case 5
L00423	EQU	*		case 9
L00424	EQU	*		case 10
* Line minilisp.c:832: return with value
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	LBRA	L00145		return (minilisp.c:832)
L00425	EQU	*		case 3
* Line minilisp.c:835: init of variable bind
* Line minilisp.c:835: function call: find()
	LDX	8,U		indirection of variable obj
	LDX	,X		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:824
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_find	
	LEAS	4,S	
	STD	-2,U		variable bind
* Line minilisp.c:836: if
* optim: storeLoad
	ADDD	#0	
	BNE	L00429	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:837: function call: printf()
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LEAX	,X		member name of val
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00251,PCR	"UNDEFINED SYMBOL: %s\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
* Line minilisp.c:837: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00429	EQU	*		else
* Useless label removed
* Line minilisp.c:838: return with value
	LDX	-2,U		variable bind
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	LBRA	L00145		return (minilisp.c:838)
L00426	EQU	*		case 2
* Line minilisp.c:842: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:824
* optim: remove16BitStackOperation
	LEAX	-16,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:842: for init
* Line minilisp.c:842: init of variable i
	CLRA
	LDB	#$01		1
	STD	-18,U		variable i
	BRA	L00432		jump to for condition
L00431	EQU	*
* Line minilisp.c:842: for body
* Line minilisp.c:842: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-16,U		address of array root_ADD_ROOT_
	LDD	-18,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:842: for increment(s)
	LDD	-18,U	
	ADDD	#1	
	STD	-18,U	
L00432	EQU	*
* Line minilisp.c:842: for condition
	LDD	-18,U		variable i
	CMPD	#$03	
	BLE	L00431	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:842: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-8,U		index 4 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:842: assignment: =
	LEAX	-16,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:842: init of variable fn
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-6,U		variable fn
* Line minilisp.c:842: init of variable expanded
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable expanded
* Line minilisp.c:842: init of variable args
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable args
* Line minilisp.c:843: assignment: =
* Line minilisp.c:843: function call: macroexpand()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:824
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_macroexpand
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-4,U		indirection of variable expanded
* 
	STD	,X	
* Line minilisp.c:844: if
* optim: optimizeIndexedX
* optim: optimize16BitStackOps2
* optim: optimize16BitStackOps2
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
	CMPD	[8,U]		optim: optimize16BitStackOps2
	BEQ	L00436	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:845: return with value
* Line minilisp.c:845: function call: eval()
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:824
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
	LBRA	L00145		return (minilisp.c:845)
L00436	EQU	*		else
* Useless label removed
* Line minilisp.c:846: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-6,U		indirection of variable fn
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:847: assignment: =
* Line minilisp.c:847: function call: eval()
	LDY	-6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:824
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-6,U		indirection of variable fn
* 
	STD	,X	
* Line minilisp.c:848: assignment: =
* optim: optimizeIndexedX
	LDX	[8,U]		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable args
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:849: if
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[-6,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BEQ	L00439	
* optim: condBranchOverUncondBranch
* Useless label removed
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[-6,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BEQ	L00439	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:850: function call: printf()
	LEAX	S00252,PCR	"THE HEAD OF A LIST MUST BE A FUNCTION\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:850: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00439	EQU	*		else
* Useless label removed
* Line minilisp.c:851: return with value
* Line minilisp.c:851: function call: apply()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	-6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:824
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_apply	
	LEAS	8,S	
	BRA	L00145		return (minilisp.c:851)
L00427	EQU	*		default
* Line minilisp.c:854: function call: printf()
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	PSHS	B,A		argument 2 of printf()
	LEAX	S00253,PCR	"BUG: EVAL: KNOWN TAG TYPE: %d\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
* Line minilisp.c:854: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
* Useless label removed
L00145	EQU	*		end of eval()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION eval_list(): defined at minilisp.c:760
_eval_list	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-22,S	
* Line minilisp.c:761: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:760
* optim: remove16BitStackOperation
	LEAX	-20,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:761: for init
* Line minilisp.c:761: init of variable i
	CLRA
	LDB	#$01		1
	STD	-22,U		variable i
	BRA	L00443		jump to for condition
L00442	EQU	*
* Line minilisp.c:761: for body
* Line minilisp.c:761: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-20,U		address of array root_ADD_ROOT_
	LDD	-22,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:761: for increment(s)
	LDD	-22,U	
	ADDD	#1	
	STD	-22,U	
L00443	EQU	*
* Line minilisp.c:761: for condition
	LDD	-22,U		variable i
	CMPD	#$04	
	BLE	L00442	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:761: assignment: =
* LDD #$FFFF optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-10,U		index 5 in array root_ADD_ROOT_[]
	LDD	#65535		optim: optimizeStackOperations1
	STD	,X	
* Line minilisp.c:761: assignment: =
	LEAX	-20,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:761: init of variable head
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-8,U		variable head
* Line minilisp.c:761: init of variable lp
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-6,U		variable lp
* Line minilisp.c:761: init of variable expr
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable expr
* Line minilisp.c:761: init of variable result
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable result
* Line minilisp.c:762: assignment: =
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: remove16BitStackOperation
	LDX	-8,U		indirection of variable head
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:763: for init
* Line minilisp.c:763: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	8,U	
	STD	-6,U	
	LBRA	L00447		jump to for condition
L00446	EQU	*
* Line minilisp.c:763: for body
* Line minilisp.c:764: assignment: =
* optim: optimizeIndexedX
	LDD	[-6,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable expr
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:765: assignment: =
* Line minilisp.c:765: function call: eval()
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:760
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable result
* 
	STD	,X	
* Line minilisp.c:766: assignment: =
* Line minilisp.c:766: function call: cons()
	LDY	-8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-2,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:760
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_cons	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-8,U		indirection of variable head
* 
	STD	,X	
* Useless label removed
* Line minilisp.c:763: for increment(s)
* Line minilisp.c:763: assignment: =
* optim: optimizeIndexedX
	LDX	[-6,U]		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	-6,U		indirection of variable lp
* optim: remove16BitStackOperation
	STD	,X	
L00447	EQU	*
* Line minilisp.c:763: for condition
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	PSHS	B,A	
	LDX	-6,U		indirection of variable lp
	LDD	,X		indirection
	CMPD	,S++	
	LBNE	L00446	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:768: return with value
* Line minilisp.c:768: function call: reverse()
	LDX	-8,U		indirection of variable head
	LDD	,X		indirection
	PSHS	B,A		argument 1 of reverse()
	LBSR	_reverse
	LEAS	2,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION find(): defined at minilisp.c:799
_find	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line minilisp.c:800: for init
* Line minilisp.c:800: init of variable p
* optim: optimizeIndexedX
	LDD	[4,U]		optim: optimizeIndexedX
	STD	-2,U		variable p
	BRA	L00451		jump to for condition
L00450	EQU	*
* Line minilisp.c:800: for body
* Line minilisp.c:801: for init
* Line minilisp.c:801: init of variable cell
	LDX	-2,U		variable p
	LEAX	4,X		member val of Obj
	LDD	,X		member vars of env
	STD	-4,U		variable cell
	BRA	L00455		jump to for condition
L00454	EQU	*
* Line minilisp.c:801: for body
* Line minilisp.c:802: init of variable bind
	LDX	-4,U		variable cell
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-6,U		variable bind
* Line minilisp.c:803: if
	LDX	-6,U		variable bind
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	6,U		optim: optimize16BitCompares
	BNE	L00459		optim: optimize16BitCompares
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:804: return with value
	LDD	-6,U		variable bind, declared at minilisp.c:802
	BRA	L00143		return (minilisp.c:804)
L00459	EQU	*		else
* Useless label removed
* Useless label removed
* Line minilisp.c:801: for increment(s)
* Line minilisp.c:801: assignment: =
	LDX	-4,U		variable cell
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	-4,U	
L00455	EQU	*
* Line minilisp.c:801: for condition
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-4,U		optim: optimize16BitCompares
	BNE	L00454		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label removed
* Useless label removed
* Line minilisp.c:800: for increment(s)
* Line minilisp.c:800: assignment: =
	LDX	-2,U		variable p
	LEAX	4,X		member val of Obj
	LDD	2,X		member up of env
	STD	-2,U	
L00451	EQU	*
* Line minilisp.c:800: for condition
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-2,U		optim: optimize16BitCompares
	LBNE	L00450		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:807: return with value
	CLRA
	CLRB
* optim: branchToNextLocation
L00143	EQU	*		end of find()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION findDirEntry(): defined at /usr/local/share/cmoc/disk.h:629
_findDirEntry	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-273,S	
* Line /usr/local/share/cmoc/disk.h:632: function call: normalizeFilename()
	LDD	6,U		variable filename, declared at /usr/local/share/cmoc/disk.h:629
	PSHS	B,A		argument 2 of normalizeFilename()
	LEAX	-12,U		address of array normalizedFilename
	PSHS	X		argument 1 of normalizeFilename()
	LBSR	_normalizeFilename
	LEAS	4,S	
* Line /usr/local/share/cmoc/disk.h:635: for init
* Line /usr/local/share/cmoc/disk.h:635: init of variable sector
	LDB	#$03		3
	STB	-13,U		variable sector
	LBRA	L00462		jump to for condition
L00461	EQU	*
* Line /usr/local/share/cmoc/disk.h:635: for body
* Line /usr/local/share/cmoc/disk.h:638: if
* Line /usr/local/share/cmoc/disk.h:638: function call: readDiskSector()
	LDB	-13,U		variable sector, declared at /usr/local/share/cmoc/disk.h:635
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 4 of readDiskSector()
	LDB	#$11		optim: changeLoadDToLoadB
	PSHS	B,A		argument 3 of readDiskSector()
	LDB	G00183+0,PCR	variable curDriveNo, declared at /usr/local/share/cmoc/disk.h:138
* optim: stripExtraClrA_B
	PSHS	B,A		argument 2 of readDiskSector()
	LEAX	-271,U		address of array dirSector
	PSHS	X		argument 1 of readDiskSector()
	LBSR	_readDiskSector
	LEAS	8,S	
	TSTB
	BNE	L00466	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:639: return with value
	CLRA
	CLRB
	LBRA	L00093		return (/usr/local/share/cmoc/disk.h:639)
L00466	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:642: for init
* Line /usr/local/share/cmoc/disk.h:642: init of variable index
	CLRA
	CLRB
	STD	-273,U		variable index
	LBRA	L00469		jump to for condition
L00468	EQU	*
* Line /usr/local/share/cmoc/disk.h:642: for body
* Line /usr/local/share/cmoc/disk.h:644: assignment: =
* optim: optimize16BitStackOps1
* optim: optimize16BitStackOps1
	LEAX	-271,U		address of array dirSector
	TFR	X,D		as r-value
	ADDD	-273,U		optim: optimize16BitStackOps1
	STD	-15,U	
* Line /usr/local/share/cmoc/disk.h:645: if
* optim: optimizeIndexedX
	LDB	[-15,U]		optim: optimizeIndexedX
* optim: loadCmpZeroBeqOrBne
	BNE	L00473	
* optim: branchToNextLocation
* Useless label removed
	BRA	L00470		continue
L00473	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:647: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDB	[-15,U]		optim: optimizeIndexedX
* optim: stripExtraClrA_B
	CMPD	#255		optim: optimizeStackOperations1
	BNE	L00476	
* optim: condBranchOverUncondBranch
* Useless label removed
	BRA	L00471		break
L00476	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:650: if
* Line /usr/local/share/cmoc/disk.h:650: function call: memcmp()
	CLRA
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		argument 3 of memcmp()
	LEAX	-12,U		address of array normalizedFilename
* optim: optimizePshsOps
	LDD	-15,U		variable entry, declared at /usr/local/share/cmoc/disk.h:641
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_memcmp	
	LEAS	6,S	
	ADDD	#0	
	BNE	L00479	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:652: function call: memcpy()
	LDY	#$10		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-15,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable dirEntry, declared at /usr/local/share/cmoc/disk.h:629
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_memcpy	
	LEAS	6,S	
* Line /usr/local/share/cmoc/disk.h:653: return with value
	CLRA
	LDB	#$01		decimal 1 signed
	BRA	L00093		return (/usr/local/share/cmoc/disk.h:653)
L00479	EQU	*		else
* Useless label removed
L00470	EQU	*
* Line /usr/local/share/cmoc/disk.h:642: for increment(s)
* Line /usr/local/share/cmoc/disk.h:642: assignment: +=
	LDD	-273,U		variable index
	ADDD	#$20		+= operator at /usr/local/share/cmoc/disk.h:642
	STD	-273,U	
L00469	EQU	*
* Line /usr/local/share/cmoc/disk.h:642: for condition
	LDD	-273,U		variable index
	CMPD	#$0100	
	LBLO	L00468	
* optim: branchToNextLocation
L00471	EQU	*		end for
* Line /usr/local/share/cmoc/disk.h:656: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDB	[-15,U]		optim: optimizeIndexedX
* optim: stripExtraClrA_B
	CMPD	#255		optim: optimizeStackOperations1
	BNE	L00482	
* optim: condBranchOverUncondBranch
* Useless label removed
	BRA	L00464		break
L00482	EQU	*		else
* Useless label removed
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:635: for increment(s)
	INC	-13,U	
L00462	EQU	*
* Line /usr/local/share/cmoc/disk.h:635: for condition
	LDB	-13,U		variable sector
	CMPB	#$12	
	LBLS	L00461	
* optim: branchToNextLocation
L00464	EQU	*		end for
* Line /usr/local/share/cmoc/disk.h:660: return with value
	CLRA
	CLRB
* optim: branchToNextLocation
L00093	EQU	*		end of findDirEntry()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION forward(): defined at minilisp.c:249
_forward	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-4,S	
* Line minilisp.c:252: init of variable offset
	LDD	G00195+0,PCR	variable from_space, declared at minilisp.c:127
	PSHS	B,A	
	LDD	4,U		variable obj, declared at minilisp.c:249
	SUBD	,S++	
	STD	-4,U		variable offset
* Line minilisp.c:253: if
* optim: storeLoad
	ADDD	#0	
	BLT	L00484	
* optim: branchToNextLocation
* Useless label removed
* optim: optimize16BitStackOps1
* optim: optimize16BitStackOps1
	LDD	#$1080		decimal 4224 signed
	CMPD	-4,U		optim: optimize16BitStackOps1
	BGT	L00485	
* optim: condBranchOverUncondBranch
L00484	EQU	*		then
* Line minilisp.c:254: return with value
	LDD	4,U		variable obj, declared at minilisp.c:249
	LBRA	L00105		return (minilisp.c:254)
L00485	EQU	*		else
* Useless label removed
* Line minilisp.c:258: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[4,U]		optim: optimizeIndexedX
	CMPD	#8		optim: optimizeStackOperations1
	BNE	L00489	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:259: return with value
	LDX	4,U		variable obj
	LEAX	4,X		member val of Obj
	LDD	,X		member moved of val
	BRA	L00105		return (minilisp.c:259)
L00489	EQU	*		else
* Useless label removed
* Line minilisp.c:262: init of variable newloc
	LDD	G00201+0,PCR	variable scan2, declared at minilisp.c:245
	STD	-2,U		variable newloc
* Line minilisp.c:263: function call: memcpy()
	LDX	4,U		variable obj
	LDY	2,X		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
* optim: removeUselessLdx
	PSHS	X		optim: transformPshsDPshsD
* optim: removeUselessLdd
	PSHS	B,A		argument 1 of memcpy()
	LBSR	_memcpy	
	LEAS	6,S	
* Line minilisp.c:264: assignment: =
	LDX	4,U		variable obj
	LDD	2,X		member size of Obj
	ADDD	G00201+0,PCR	optim: pushDLoadAdd
* 
* 
	STD	G00201+0,PCR
* Line minilisp.c:268: assignment: =
	CLRA
	LDB	#$08		decimal 8 signed
* optim: pushDLoadXLoadD
	LDX	4,U		variable obj
* 
	STD	,X	
* Line minilisp.c:269: assignment: =
	LDD	-2,U		variable newloc, declared at minilisp.c:262
* optim: remove16BitStackOperation
	LDX	4,U		variable obj
	LEAX	4,X		member val of Obj
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:270: return with value
	LDD	-2,U		variable newloc, declared at minilisp.c:262
* optim: branchToNextLocation
L00105	EQU	*		end of forward()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION forward_root_objects(): defined at minilisp.c:274
_forward_root_objects	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-4,S	
* Line minilisp.c:275: assignment: =
* Line minilisp.c:275: function call: forward()
	LDD	G00191+0,PCR	variable Symbols, declared at minilisp.c:112
	PSHS	B,A		argument 1 of forward()
	LBSR	_forward
	LEAS	2,S	
	STD	G00191+0,PCR
* Line minilisp.c:276: for init
* Line minilisp.c:276: init of variable frame
	LDD	4,U		variable root, declared at minilisp.c:274
	STD	-2,U		variable frame
	LBRA	L00492		jump to for condition
L00491	EQU	*
* Line minilisp.c:276: for body
* Line minilisp.c:277: for init
* Line minilisp.c:277: init of variable i
	CLRA
	LDB	#$01		1
	STD	-4,U		variable i
	BRA	L00496		jump to for condition
L00495	EQU	*
* Line minilisp.c:277: for body
* Line minilisp.c:278: if
	LDX	-2,U		pointer frame
	LDD	-4,U		variable i
	LSLB
	ROLA
* optimizeLoadDX
	LDD	D,X		get r-value
* optim: loadCmpZeroBeqOrBne
	BEQ	L00500	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:279: assignment: =
* Line minilisp.c:279: function call: forward()
	LDX	-2,U		pointer frame
	LDD	-4,U		variable i
	LSLB
	ROLA
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		argument 1 of forward()
	LBSR	_forward
	LEAS	2,S	
	PSHS	B,A	
	LDX	-2,U		pointer frame
	LDD	-4,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	,S++	
	STD	,X	
L00500	EQU	*		else
* Useless label removed
* Useless label removed
* Line minilisp.c:277: for increment(s)
	LDD	-4,U	
	ADDD	#1	
	STD	-4,U	
L00496	EQU	*
* Line minilisp.c:277: for condition
* LDD #$FFFF optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LDX	-2,U		pointer frame
	LDD	-4,U		variable i
	LSLB
	ROLA
* optimizeLoadDX
	LDD	D,X		get r-value
	CMPD	#65535		optim: optimizeStackOperations1
	LBNE	L00495	
* optim: branchToNextLocation
* Useless label removed
* Useless label removed
* Line minilisp.c:276: for increment(s)
* Line minilisp.c:276: assignment: =
	LDX	-2,U		optim: removeTfrDX
* optim: removeTfrDX
	LDD	,X		indirection
	STD	-2,U	
L00492	EQU	*
* Line minilisp.c:276: for condition
	LDD	-2,U		variable frame, declared at minilisp.c:276
* optim: loadCmpZeroBeqOrBne
	LBNE	L00491	
* optim: branchToNextLocation
* Useless label removed
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION gc(): defined at minilisp.c:284
_gc	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:285: do-while
* Useless label removed
* Line minilisp.c:285: if
	LDB	G00197+0,PCR	variable gc_running, declared at minilisp.c:133
* optim: loadCmpZeroBeqOrBne
	BEQ	L00506	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:285: function call: printf()
	LEAX	S00223,PCR	"!gc_running"
* optim: optimizePshsOps
	LDD	#$011D		decimal 285 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAY	S00222,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	S00211,PCR	"***ASSERT FAILED: %s:%u: %s\n"
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_printf	
	LEAS	8,S	
L00508	EQU	*
* Line minilisp.c:285: for body
* Useless label removed
	BRA	L00508	
* Useless label removed
L00506	EQU	*		else
* Useless label removed
* Useless label removed
* Line minilisp.c:286: assignment: =
	CLRA
* optim: stripConsecutiveLoadsToSameReg
	LDB	#$01	
	STB	G00197+0,PCR
* Line minilisp.c:289: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	G00194+0,PCR
	STD	G00195+0,PCR
* Line minilisp.c:290: assignment: =
	LEAX	G00192+0,PCR	address of array memory1
	TFR	X,D		as r-value
	PSHS	B,A	
	LDD	G00195+0,PCR	variable from_space, declared at minilisp.c:127
	CMPD	,S++	
	BEQ	L00512		if true
	CLRB
	BRA	L00513		false
L00512	EQU	*
	LDB	#1	
L00513	EQU	*
	TSTB
	BEQ	L00514		if conditional expression is false
	LEAX	G00193+0,PCR	address of array memory2
	TFR	X,D		as r-value
	BRA	L00515		end of true expression of conditional
L00514	EQU	*
	LEAX	G00192+0,PCR	address of array memory1
	TFR	X,D		as r-value
L00515	EQU	*
	STD	G00194+0,PCR
* Line minilisp.c:293: assignment: =
* Line minilisp.c:293: assignment: =
* optim: storeLoad
	STD	G00201+0,PCR
	STD	G00200+0,PCR
* Line minilisp.c:296: function call: forward_root_objects()
	LDD	4,U		variable root, declared at minilisp.c:284
	PSHS	B,A		argument 1 of forward_root_objects()
	LBSR	_forward_root_objects
	LEAS	2,S	
* Line minilisp.c:301: while
L00517	EQU	*		while condition at minilisp.c:301
	LDD	G00201+0,PCR	variable scan2, declared at minilisp.c:245
	PSHS	B,A	
	LDD	G00200+0,PCR	variable scan1, declared at minilisp.c:244
	CMPD	,S++	
	LBHS	L00518	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:302: switch
	LDX	G00200+0,PCR	variable scan1
	LDD	,X		member type of Obj
	CMPD	#$01		case 1
	BEQ	L00520	
	CMPD	#$03		case 3
	BEQ	L00521	
	CMPD	#$04		case 4
	BEQ	L00522	
	CMPD	#$02		case 2
	BEQ	L00523	
	CMPD	#$05		case 5
	LBEQ	L00524	
	CMPD	#$06		case 6
	LBEQ	L00525	
	CMPD	#$07		case 7
	LBEQ	L00526	
	LBRA	L00527		switch default
L00520	EQU	*		case 1
L00521	EQU	*		case 3
L00522	EQU	*		case 4
	LBRA	L00519		break
L00523	EQU	*		case 2
* Line minilisp.c:309: assignment: =
* Line minilisp.c:309: function call: forward()
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	PSHS	B,A		argument 1 of forward()
	LBSR	_forward
	LEAS	2,S	
	PSHS	B,A	
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LDD	,S++	
	STD	,X	
* Line minilisp.c:310: assignment: =
* Line minilisp.c:310: function call: forward()
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	PSHS	B,A		argument 1 of forward()
	LBSR	_forward
	LEAS	2,S	
	PSHS	B,A	
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LEAX	2,X		member cdr of cell
	LDD	,S++	
	STD	,X	
	LBRA	L00519		break
L00524	EQU	*		case 5
L00525	EQU	*		case 6
* Line minilisp.c:314: assignment: =
* Line minilisp.c:314: function call: forward()
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LDD	,X		member params of func
	PSHS	B,A		argument 1 of forward()
	LBSR	_forward
	LEAS	2,S	
	PSHS	B,A	
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LDD	,S++	
	STD	,X	
* Line minilisp.c:315: assignment: =
* Line minilisp.c:315: function call: forward()
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LDD	2,X		member body of func
	PSHS	B,A		argument 1 of forward()
	LBSR	_forward
	LEAS	2,S	
	PSHS	B,A	
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LEAX	2,X		member body of func
	LDD	,S++	
	STD	,X	
* Line minilisp.c:316: assignment: =
* Line minilisp.c:316: function call: forward()
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LDD	4,X		member env of func
	PSHS	B,A		argument 1 of forward()
	LBSR	_forward
	LEAS	2,S	
	PSHS	B,A	
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LEAX	4,X		member env of func
	LDD	,S++	
	STD	,X	
	LBRA	L00519		break
L00526	EQU	*		case 7
* Line minilisp.c:319: assignment: =
* Line minilisp.c:319: function call: forward()
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LDD	,X		member vars of env
	PSHS	B,A		argument 1 of forward()
	LBSR	_forward
	LEAS	2,S	
	PSHS	B,A	
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LDD	,S++	
	STD	,X	
* Line minilisp.c:320: assignment: =
* Line minilisp.c:320: function call: forward()
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LDD	2,X		member up of env
	PSHS	B,A		argument 1 of forward()
	LBSR	_forward
	LEAS	2,S	
	PSHS	B,A	
	LDX	G00200+0,PCR	variable scan1
	LEAX	4,X		member val of Obj
	LEAX	2,X		member up of env
	LDD	,S++	
	STD	,X	
	BRA	L00519		break
L00527	EQU	*		default
* Line minilisp.c:323: function call: printf()
	LDX	G00200+0,PCR	variable scan1
	LDD	,X		member type of Obj
	PSHS	B,A		argument 2 of printf()
	LEAX	S00224,PCR	"BUG: COPY: UNKNOWN TYPE%d\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
* Line minilisp.c:323: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00519	EQU	*		end of switch
* Line minilisp.c:325: assignment: =
	LDX	G00200+0,PCR	variable scan1
	LDD	2,X		member size of Obj
	ADDD	G00200+0,PCR	optim: pushDLoadAdd
* 
* 
	STD	G00200+0,PCR
	LBRA	L00517		go to while condition
L00518	EQU	*		after end of while starting at minilisp.c:301
* Line minilisp.c:329: init of variable old_nused
	LDD	G00196+0,PCR	variable mem_nused, declared at minilisp.c:130
	STD	-2,U		variable old_nused
* Line minilisp.c:330: assignment: =
	LDD	G00194+0,PCR	variable memory, declared at minilisp.c:124
	PSHS	B,A	
	LDD	G00200+0,PCR	variable scan1, declared at minilisp.c:244
	SUBD	,S++	
	STD	G00196+0,PCR
* Line minilisp.c:331: if
	LDB	G00198+0,PCR	variable debug_gc, declared at minilisp.c:134
* optim: loadCmpZeroBeqOrBne
	BEQ	L00529	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:332: function call: printf()
	LDX	-2,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	G00196+0,PCR	variable mem_nused, declared at minilisp.c:130
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	S00225,PCR	"GC: %x/%x\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	6,S	
L00529	EQU	*		else
* Useless label removed
* Line minilisp.c:333: assignment: =
	CLRA
	CLRB
* optim: removeClr
	STB	G00197+0,PCR
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION getCurrentlyAvailableBytes(): defined at /usr/local/share/cmoc/disk.h:418
_getCurrentlyAvailableBytes	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line /usr/local/share/cmoc/disk.h:423: if
	LDX	4,U		variable fd
	LDD	274,X		member curSectorAvailBytes of FileDesc
* optim: loadCmpZeroBeqOrBne
	BNE	L00532	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:427: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LDX	6,U		indirection of variable numAvailBytes
	LDB	#0		optim: removeAndOrMulAddSub
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:428: return with value
* optim: removeClr
* optim: removeClr
	LBRA	L00085		return (/usr/local/share/cmoc/disk.h:428)
L00532	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:431: do-while
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:431: if
	LDX	4,U		variable fd
	LDD	274,X		member curSectorAvailBytes of FileDesc
	PSHS	B,A	
* optim: removeUselessLdx
	LDD	16,X		member secOffset of FileDesc
	CMPD	,S++	
	BLS	L00538	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:431: function call: printf()
	LEAX	S00220,PCR	"fd->secOffset <= fd->curSectorAvailBytes"
* optim: optimizePshsOps
	LDD	#$01AF		decimal 431 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAY	S00212,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	S00211,PCR	"***ASSERT FAILED: %s:%u: %s\n"
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_printf	
	LEAS	8,S	
L00540	EQU	*
* Line /usr/local/share/cmoc/disk.h:431: for body
* Useless label removed
	BRA	L00540	
* Useless label removed
L00538	EQU	*		else
* Useless label removed
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:433: init of variable availBytes
	LDX	4,U		variable fd
	LDD	16,X		member secOffset of FileDesc
	PSHS	B,A	
* optim: removeUselessLdx
	LEAX	18,X		member curSector of FileDesc
	TFR	X,D	
	ADDD	,S++	
	STD	-2,U		variable availBytes
* Line /usr/local/share/cmoc/disk.h:435: assignment: =
	LDX	4,U		variable fd
	LDD	16,X		member secOffset of FileDesc
	PSHS	B,A	
* optim: removeUselessLdx
	LDD	274,X		member curSectorAvailBytes of FileDesc
	SUBD	,S++	
* optim: pushDLoadXLoadD
	LDX	6,U		indirection of variable numAvailBytes
* 
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:438: return with value
	LDD	-2,U		variable availBytes, declared at /usr/local/share/cmoc/disk.h:433
* optim: branchToNextLocation
L00085	EQU	*		end of getCurrentlyAvailableBytes()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION getGranuleLength(): defined at /usr/local/share/cmoc/disk.h:608
_getGranuleLength	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-1,S	
* Line /usr/local/share/cmoc/disk.h:610: if
	LDD	4,U		variable fat, declared at /usr/local/share/cmoc/disk.h:608
* optim: loadCmpZeroBeqOrBne
	BNE	L00545	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:611: return with value
	CLRA
	CLRB
	LBRA	L00092		return (/usr/local/share/cmoc/disk.h:611)
L00545	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:612: if
	LDB	7,U		variable granule
	CMPB	#$00	
	BHS	L00548	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:613: return with value
	CLRA
	CLRB
	LBRA	L00092		return (/usr/local/share/cmoc/disk.h:613)
L00548	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:614: if
	LDB	7,U		variable granule
	CMPB	#$43	
	BLS	L00551	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:615: return with value
	CLRA
	CLRB
	BRA	L00092		return (/usr/local/share/cmoc/disk.h:615)
L00551	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:617: init of variable entry
	LDX	4,U		pointer fat
	LDB	7,U		variable granule
	CLRA			index expression is of byte type
	ABX			optim: removeAndOrMulAddSub
	LDB	,X		get r-value
	STB	-1,U		variable entry
* Line /usr/local/share/cmoc/disk.h:618: if
* optim: storeLoad
	CMPB	#$C9	
	BLS	L00554	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:619: return with value
	CLRA
	CLRB
	BRA	L00092		return (/usr/local/share/cmoc/disk.h:619)
L00554	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:620: if
	LDB	-1,U		variable entry
	CMPB	#$C1	
	BLO	L00557	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:621: return with value
	LDX	8,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$C1		decimal 193 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LDB	-1,U		variable entry, declared at /usr/local/share/cmoc/disk.h:617
* optim: stripExtraClrA_B
	SUBD	,S++	
	TFR	D,X		optim: stripExtraPulsX
	LDD	#$0100		decimal 256 signed
* optim: stripExtraPulsX
	LBSR	MUL16	
	ADDD	,S++	
	BRA	L00092		return (/usr/local/share/cmoc/disk.h:621)
L00557	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:623: return with value
	LDD	#$0900		decimal 2304 signed
* optim: branchToNextLocation
L00092	EQU	*		end of getGranuleLength()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION getNextSector(): defined at /usr/local/share/cmoc/disk.h:463
_getNextSector	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line /usr/local/share/cmoc/disk.h:467: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable fd
	LDB	8,X		member curGran of FileDesc
* optim: stripExtraClrA_B
	CMPD	#255		optim: optimizeStackOperations1
	BNE	L00560	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:470: return with value
	CLRA
	CLRB
	LBRA	L00087		return (/usr/local/share/cmoc/disk.h:470)
L00560	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:475: function call: granuleToTrack()
	LEAY	-5,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-6,U		variable track, declared at /usr/local/share/cmoc/disk.h:473
	PSHS	Y,X		optim: optimizePshsOps
	LDX	4,U		variable fd
	LDB	8,X		member curGran of FileDesc
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of granuleToTrack()
	LBSR	_granuleToTrack
	LEAS	6,S	
* Line /usr/local/share/cmoc/disk.h:476: if
* Line /usr/local/share/cmoc/disk.h:476: function call: readDiskSector()
	LDX	4,U		variable fd
	LDB	9,X		member curSec of FileDesc
	CLRA			promotion of binary operand
	PSHS	B		optim: stripPushLeas
	LDB	-5,U		variable sec, declared at /usr/local/share/cmoc/disk.h:474
* optim: stripExtraClrA_B
* optim: stripPushLeas1
	ADDB	,S+	
* optim: stripExtraClrA_B
	PSHS	B,A		argument 4 of readDiskSector()
	LDB	-6,U		variable track, declared at /usr/local/share/cmoc/disk.h:473
* optim: stripExtraClrA_B
	PSHS	B,A		argument 3 of readDiskSector()
* optim: removeUselessLdx
	LDB	,X		member drive of FileDesc
* optim: stripExtraClrA_B
	PSHS	B,A		argument 2 of readDiskSector()
* optim: removeUselessLdx
	LEAX	18,X		member curSector of FileDesc
	TFR	X,D	
	PSHS	B,A		argument 1 of readDiskSector()
	LBSR	_readDiskSector
	LEAS	8,S	
	TSTB
	BNE	L00563	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:477: return with value
	CLRA
	CLRB
	LBRA	L00087		return (/usr/local/share/cmoc/disk.h:477)
L00563	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:482: if
* Line /usr/local/share/cmoc/disk.h:482: function call: isLastSectorOfFile()
	LDD	4,U		variable fd, declared at /usr/local/share/cmoc/disk.h:463
	PSHS	B,A		argument 1 of isLastSectorOfFile()
	LBSR	_isLastSectorOfFile
	LEAS	2,S	
	TSTB
	BEQ	L00566	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:483: assignment: =
	LDX	4,U		variable fd
	LDD	2,X		member numBytesLastSector of FileDesc
* optim: remove16BitStackOperation
* optim: removeUselessLdx
	LEAX	274,X		member curSectorAvailBytes of FileDesc
* optim: remove16BitStackOperation
	STD	,X	
	BRA	L00567		jump over else clause
L00566	EQU	*		else
* Line /usr/local/share/cmoc/disk.h:485: assignment: =
* LDD #$0100 optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable fd
	LEAX	274,X		member curSectorAvailBytes of FileDesc
	LDD	#256		optim: optimizeStackOperations1
	STD	,X	
L00567	EQU	*		end if
* Line /usr/local/share/cmoc/disk.h:490: init of variable fat
* Line /usr/local/share/cmoc/disk.h:490: function call: updateFAT()
	LBSR	_updateFAT
	STD	-4,U		variable fat
* Line /usr/local/share/cmoc/disk.h:491: if
* optim: storeLoad
	ADDD	#0	
	BNE	L00569	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:492: return with value
	CLRA
	CLRB
	LBRA	L00087		return (/usr/local/share/cmoc/disk.h:492)
L00569	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:493: init of variable g
	LDX	-4,U		pointer fat
	PSHS	X		preserve array address, then eval array index
	LDX	4,U		variable fd
	LDB	8,X		member curGran of FileDesc
	CLRA			index expression is of byte type
	PULS	X		retrieve array address
* optimizeLoadDX
	LDB	D,X		get r-value
	STB	-2,U		variable g
* Line /usr/local/share/cmoc/disk.h:495: if
* optim: storeLoad
	CMPB	#$C1	
	BLO	L00572	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:496: assignment: =
	LDB	-2,U	
	CLRA
	ADDD	#$FF40		65344
	STB	-1,U	
	BRA	L00573		jump over else clause
L00572	EQU	*		else
* Line /usr/local/share/cmoc/disk.h:498: assignment: =
	CLRA
* optim: stripConsecutiveLoadsToSameReg
	LDB	#$09	
	STB	-1,U	
L00573	EQU	*		end if
	LDX	4,U		variable fd
	LEAX	9,X		member curSec of FileDesc
	INC	,X	
* optim: stripConsecutiveLoadsToSameReg
* Line /usr/local/share/cmoc/disk.h:506: if
* optim: optimize8BitStackOps
	CLRA			promotion of binary operand
* optim: optimize8BitStackOps
	LDX	4,U		variable fd
	LDB	9,X		member curSec of FileDesc
* optim: stripExtraClrA_B
* optim: stripPushLeas1
	CMPB	-1,U		optim: optimize8BitStackOps
	BLS	L00575	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:508: if
	LDB	-2,U		variable g
	CMPB	#$C1	
	BLO	L00578	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:509: assignment: =
	CLRA
* LDB #$FF optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDX	4,U		variable fd
	LEAX	8,X		member curGran of FileDesc
	LDB	#255		optim: optimizeStackOperations1
	STB	,X	
	BRA	L00579		jump over else clause
L00578	EQU	*		else
* Line /usr/local/share/cmoc/disk.h:512: assignment: =
	CLRA
* LDB #$01 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDX	4,U		variable fd
	LEAX	9,X		member curSec of FileDesc
	LDB	#1		optim: optimizeStackOperations1
	STB	,X	
* Line /usr/local/share/cmoc/disk.h:513: assignment: =
	LDB	-2,U		variable g, declared at /usr/local/share/cmoc/disk.h:493
* optim: stripExtraPushPullB
	LDX	4,U		variable fd
	LEAX	8,X		member curGran of FileDesc
* optim: stripExtraPushPullB
	STB	,X	
L00579	EQU	*		end if
L00575	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:517: return with value
	CLRA
	LDB	#$01		decimal 1 signed
* optim: branchToNextLocation
L00087	EQU	*		end of getNextSector()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION getchar(): defined at minilisp.c:433
_getchar	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:435: if
	LDB	G00209+0,PCR	variable has_file_data, declared at minilisp.c:431
* optim: loadCmpZeroBeqOrBne
	BEQ	L00581	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:436: assignment: =
	CLRA
	CLRB
* optim: removeClr
	STB	G00209+0,PCR
* Line minilisp.c:437: return with value
	LDB	G00210+0,PCR	variable file_data, declared at minilisp.c:432
	LBRA	L00118		return (minilisp.c:437)
L00581	EQU	*		else
* Useless label removed
* Line minilisp.c:441: if
	LDB	G00207+0,PCR	variable doing_load, declared at minilisp.c:429
* optim: loadCmpZeroBeqOrBne
	BEQ	L00584	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:442: init of variable num_read
* Line minilisp.c:442: function call: read()
	CLRA
	LDB	#$01		constant expression: 1 decimal
	PSHS	B,A		argument 3 of read()
	LEAY	G00210+0,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	G00208+0,PCR	variable fd, declared at minilisp.c:430
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_read	
	LEAS	6,S	
	STD	-2,U		variable num_read
* Line minilisp.c:444: if
* optim: storeLoad
	ADDD	#0	
	BNE	L00587	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:445: function call: close()
	LEAX	G00208+0,PCR	variable fd, declared at minilisp.c:430
	PSHS	X		argument 1 of close()
	LBSR	_close	
	LEAS	2,S	
* Line minilisp.c:446: assignment: =
	CLRA
	CLRB
* optim: removeClr
	STB	G00207+0,PCR
	BRA	L00588		jump over else clause
L00587	EQU	*		else
* Line minilisp.c:448: return with value
	LDB	G00210+0,PCR	variable file_data, declared at minilisp.c:432
	LBRA	L00118		return (minilisp.c:448)
L00588	EQU	*		end if
L00584	EQU	*		else
* Useless label removed
* Line minilisp.c:453: if
	LDB	G00204+0,PCR	variable has_data, declared at minilisp.c:426
* optim: loadCmpZeroBeqOrBne
	BEQ	L00590	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:454: init of variable c
	LDX	G00205+0,PCR	get pointer start_pos
	LDB	,X+		indirection with post-increment
	STX	G00205+0,PCR	store incremented pointer start_pos
	STB	-1,U		variable c
* Line minilisp.c:455: if
	LDD	G00206+0,PCR	variable end_pos, declared at minilisp.c:428
	PSHS	B,A	
	LDD	G00205+0,PCR	variable start_pos, declared at minilisp.c:427
	CMPD	,S++	
	BLO	L00593	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:456: assignment: =
	CLRA
	CLRB
* optim: removeClr
	STB	G00204+0,PCR
L00593	EQU	*		else
* Useless label removed
* Line minilisp.c:458: return with value
* Line minilisp.c:458: function call: screen2ascii()
	LDB	-1,U		variable c, declared at minilisp.c:454
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of screen2ascii()
	LBSR	_screen2ascii
	LEAS	2,S	
	LBRA	L00118		return (minilisp.c:458)
L00590	EQU	*		else
* Useless label removed
* Line minilisp.c:461: assignment: =
* Line minilisp.c:461: assignment: =
	LDD	$88		decimal 136
	STD	G00206+0,PCR
	STD	G00205+0,PCR
* Line minilisp.c:462: assignment: =
	CLRA
* optim: stripConsecutiveLoadsToSameReg
	LDB	#$01	
	STB	G00204+0,PCR
* Line minilisp.c:463: while
L00596	EQU	*		while condition at minilisp.c:463
* Useless label removed
* Line minilisp.c:465: for init
* Line minilisp.c:465: assignment: =
* Line minilisp.c:465: function call: waitkey()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		argument 1 of waitkey()
	LBSR	_waitkey
	LEAS	2,S	
	STB	-1,U	
	BRA	L00599		jump to for condition
L00598	EQU	*
* Line minilisp.c:465: for body
* Useless label removed
* Line minilisp.c:465: for increment(s)
* Line minilisp.c:465: assignment: =
* Line minilisp.c:465: function call: inkey()
	LBSR	_inkey	
	STB	-1,U	
L00599	EQU	*
* Line minilisp.c:465: for condition
	LDB	-1,U		variable c, declared at minilisp.c:464
* optim: loadCmpZeroBeqOrBne
	BEQ	L00598	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:467: if
	LDB	-1,U		variable c
	CMPB	#$08	
	BNE	L00603	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDD	G00205+0,PCR	variable start_pos, declared at minilisp.c:427
	PSHS	B,A	
	LDD	G00206+0,PCR	variable end_pos, declared at minilisp.c:428
	CMPD	,S++	
	BLS	L00603	
* optim: condBranchOverUncondBranch
* Useless label removed
	LEAX	G00206+0,PCR	variable end_pos, declared at minilisp.c:428
	LDD	,X	
	SUBD	#1	
	STD	,X	
	ADDD	#1		post increment yields initial value
* Line minilisp.c:469: assignment: =
* Line minilisp.c:469: function call: ascii2screen()
	LDB	#$20		optim: lddToLDB
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of ascii2screen()
	LBSR	_ascii2screen
	LEAS	2,S	
* optim: stripExtraPushPullB
	LDX	G00206+0,PCR	indirection of variable end_pos
* optim: stripExtraPushPullB
	STB	,X	
* Line minilisp.c:470: assignment: =
	LDD	G00206+0,PCR
	STD	$88	
	LBRA	L00596		continue
L00603	EQU	*		else
* Useless label removed
* Line minilisp.c:475: if
* LDD #$01DF optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LDD	G00205+0,PCR	variable start_pos, declared at minilisp.c:427
	PSHS	B,A	
	LDD	G00206+0,PCR	variable end_pos, declared at minilisp.c:428
	SUBD	,S++	
	CMPD	#479		optim: optimizeStackOperations1
	BLS	L00607	
* optim: condBranchOverUncondBranch
* Useless label removed
	LBRA	L00596		continue
L00607	EQU	*		else
* Useless label removed
* Line minilisp.c:480: if
	LDB	-1,U		variable c
	CMPB	#$03	
	BEQ	L00609	
* optim: branchToNextLocation
* Useless label removed
	LDB	-1,U		variable c
	CMPB	#$0D	
	LBNE	L00610	
* optim: condBranchOverUncondBranch
L00609	EQU	*		then
* Line minilisp.c:481: assignment: =
	LDD	$88		decimal 136
	STD	G00206+0,PCR
* Line minilisp.c:482: if
* optim: storeLoad
	CMPD	#$05E0	
	BLO	L00614	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:483: assignment: =
	LDD	G00205+0,PCR	variable start_pos
	ADDD	#$FFE0		65504
	STD	G00205+0,PCR
L00614	EQU	*		else
* Useless label removed
* Line minilisp.c:485: function call: printf()
	LEAX	S00228,PCR	"\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:486: assignment: =
	LDD	$88		decimal 136
	STD	G00206+0,PCR
* Line minilisp.c:488: if
	LDB	-1,U		variable c
	CMPB	#$03	
	LBNE	L00617	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:489: function call: memcpy()
	LDD	G00205+0,PCR	variable start_pos, declared at minilisp.c:427
	PSHS	B,A	
	LDD	G00206+0,PCR	variable end_pos, declared at minilisp.c:428
	SUBD	,S++	
	PSHS	B,A		argument 3 of memcpy()
	LDD	G00205+0,PCR	variable start_pos, declared at minilisp.c:427
	PSHS	B,A		argument 2 of memcpy()
	LEAX	G00203+0,PCR	address of array buffer
	PSHS	X		argument 1 of memcpy()
	LBSR	_memcpy	
	LEAS	6,S	
* Line minilisp.c:490: assignment: =
	LDD	G00205+0,PCR	variable start_pos, declared at minilisp.c:427
	PSHS	B,A	
	LDD	G00206+0,PCR	variable end_pos, declared at minilisp.c:428
	SUBD	,S++	
	PSHS	B,A	
	LEAX	G00203+0,PCR	address of array buffer
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	G00206+0,PCR
* Line minilisp.c:491: assignment: =
	LEAX	G00203+0,PCR	address of array buffer
	TFR	X,D		as r-value
	LEAX	G00203+0,PCR
* optim: optimizeTfrOp
	STX	G00205+0,PCR	optim: optimizeTfrOp
* Line minilisp.c:492: assignment: =
	LDX	G00205+0,PCR	get pointer start_pos
	LDB	,X+		indirection with post-increment
	STX	G00205+0,PCR	store incremented pointer start_pos
	STB	-1,U	
* Line minilisp.c:493: if
	LDD	G00206+0,PCR	variable end_pos, declared at minilisp.c:428
	PSHS	B,A	
	LDD	G00205+0,PCR	variable start_pos, declared at minilisp.c:427
	CMPD	,S++	
	BLO	L00620	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:494: assignment: =
	CLRA
	CLRB
* optim: removeClr
	STB	G00204+0,PCR
L00620	EQU	*		else
* Useless label removed
* Line minilisp.c:496: return with value
* Line minilisp.c:496: function call: screen2ascii()
	LDB	-1,U		variable c, declared at minilisp.c:464
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of screen2ascii()
	LBSR	_screen2ascii
	LEAS	2,S	
	BRA	L00118		return (minilisp.c:496)
L00617	EQU	*		else
* Useless label removed
	LBRA	L00596		continue
L00610	EQU	*		else
* Useless label removed
* Line minilisp.c:502: if
	LDB	-1,U		variable c
	CMPB	#$20	
	BLT	L00623	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:503: if
	LDD	G00206+0,PCR	variable end_pos
	CMPD	#$05FF	
	BLO	L00626	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:504: assignment: =
	LDD	G00205+0,PCR	variable start_pos
	ADDD	#$FFE0		65504
	STD	G00205+0,PCR
L00626	EQU	*		else
* Useless label removed
* Line minilisp.c:506: function call: printf()
	LDB	-1,U		variable c, declared at minilisp.c:464
	SEX			promoting byte argument to word
	PSHS	B,A		argument 2 of printf()
	LEAX	S00229,PCR	"%c"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
* Line minilisp.c:507: assignment: =
	LDD	$88		decimal 136
	STD	G00206+0,PCR
L00623	EQU	*		else
* Useless label removed
	LBRA	L00596		go to while condition
* Useless label removed
L00118	EQU	*		end of getchar()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION granuleToTrack(): defined at /usr/local/share/cmoc/disk.h:525
_granuleToTrack	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line /usr/local/share/cmoc/disk.h:527: init of variable t
	LDB	5,U		variable granule, declared at /usr/local/share/cmoc/disk.h:525
	STB	-2,U		variable t
	LSR	-2,U		/usr/local/share/cmoc/disk.h:528: [inline asm] re: variable t
* Line /usr/local/share/cmoc/disk.h:529: if
	LDB	-2,U		variable t
	CMPB	#$11	
	BLO	L00629	
* optim: condBranchOverUncondBranch
* Useless label removed
	INC	-2,U		/usr/local/share/cmoc/disk.h:530: [inline asm] re: variable t
L00629	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:531: init of variable s
	LDB	5,U		variable granule, declared at /usr/local/share/cmoc/disk.h:525
	STB	-1,U		variable s
	ANDB	#1		/usr/local/share/cmoc/disk.h:532: [inline asm]
	STB	-1,U		/usr/local/share/cmoc/disk.h:533: [inline asm] re: variable s
* Line /usr/local/share/cmoc/disk.h:534: if
* optim: storeLoad
	CMPB	#$00	
	BLS	L00632	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:535: assignment: =
	CLRA
* optim: stripConsecutiveLoadsToSameReg
	LDB	#$09	
	STB	-1,U	
L00632	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:537: assignment: =
	LDB	-2,U		variable t, declared at /usr/local/share/cmoc/disk.h:527
* optim: stripExtraPushPullB
	LDX	6,U		indirection of variable track
* optim: stripExtraPushPullB
	STB	,X	
* Line /usr/local/share/cmoc/disk.h:538: assignment: =
	LDB	-1,U		variable s, declared at /usr/local/share/cmoc/disk.h:531
* optim: stripExtraPushPullB
	LDX	8,U		indirection of variable sec
* optim: stripExtraPushPullB
	STB	,X	
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION handle_defun(): defined at minilisp.c:1009
_handle_defun	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-18,S	
* Line minilisp.c:1010: if
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BNE	L00634	
* optim: branchToNextLocation
* Useless label removed
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BEQ	L00635	
* optim: condBranchOverUncondBranch
L00634	EQU	*		then
* Line minilisp.c:1011: function call: printf()
	LEAX	S00269,PCR	"MALFORMED DEFUN\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1011: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00635	EQU	*		else
* Useless label removed
* Line minilisp.c:1012: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:1009
* optim: remove16BitStackOperation
	LEAX	-16,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1012: for init
* Line minilisp.c:1012: init of variable i
	CLRA
	LDB	#$01		1
	STD	-18,U		variable i
	BRA	L00639		jump to for condition
L00638	EQU	*
* Line minilisp.c:1012: for body
* Line minilisp.c:1012: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-16,U		address of array root_ADD_ROOT_
	LDD	-18,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:1012: for increment(s)
	LDD	-18,U	
	ADDD	#1	
	STD	-18,U	
L00639	EQU	*
* Line minilisp.c:1012: for condition
	LDD	-18,U		variable i
	CMPD	#$03	
	BLE	L00638	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:1012: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-8,U		index 4 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1012: assignment: =
	LEAX	-16,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:1012: init of variable fn
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-6,U		variable fn
* Line minilisp.c:1012: init of variable sym
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable sym
* Line minilisp.c:1012: init of variable rest
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable rest
* Line minilisp.c:1013: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable sym
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1014: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable rest
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1015: assignment: =
* Line minilisp.c:1015: function call: handle_function()
	LDY	10,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1009
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_handle_function
	LEAS	8,S	
* optim: pushDLoadXLoadD
	LDX	-6,U		indirection of variable fn
* 
	STD	,X	
* Line minilisp.c:1016: function call: add_variable()
	LDY	-6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1009
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_add_variable
	LEAS	8,S	
* Line minilisp.c:1017: return with value
* optim: optimizeIndexedX
	LDD	[-6,U]		optim: optimizeIndexedX
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION handle_function(): defined at minilisp.c:989
_handle_function	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-16,S	
* Line minilisp.c:990: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BNE	L00642	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:990: function call: is_list()
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	PSHS	B,A		argument 1 of is_list()
	LBSR	_is_list
	LEAS	2,S	
	TSTB
	BEQ	L00642	
* optim: condBranchOverUncondBranch
* Useless label removed
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BEQ	L00643	
* optim: condBranchOverUncondBranch
L00642	EQU	*		then
* Line minilisp.c:991: function call: printf()
	LEAX	S00267,PCR	"MALFORMED LAMBDA\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:991: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00643	EQU	*		else
* Useless label removed
* Line minilisp.c:992: init of variable p
* optim: optimizeIndexedX
	LDX	[8,U]		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-14,U		variable p
	BRA	L00648		jump to for condition
L00647	EQU	*
* Line minilisp.c:993: for body
* Line minilisp.c:994: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-14,U		variable p
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	,X		member type of Obj
	CMPD	#3		optim: optimizeStackOperations1
	BEQ	L00652	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:995: function call: printf()
	LEAX	S00268,PCR	"PARAMETER MUST BE A SYMBOL\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:995: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00652	EQU	*		else
* Useless label removed
* Useless label removed
* Line minilisp.c:993: for increment(s)
* Line minilisp.c:993: assignment: =
	LDX	-14,U		variable p
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	-14,U	
L00648	EQU	*
* Line minilisp.c:993: for condition
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-14,U]		optim: optimizeIndexedX
	CMPD	#2		optim: optimizeStackOperations1
	BEQ	L00647	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:996: if
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-14,U		optim: optimize16BitCompares
	BEQ	L00655		optim: optimize16BitCompares
* optim: condBranchOverUncondBranch
* Useless label removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-14,U]		optim: optimizeIndexedX
	CMPD	#3		optim: optimizeStackOperations1
	BEQ	L00655	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:997: function call: printf()
	LEAX	S00268,PCR	"PARAMETER MUST BE A SYMBOL\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:997: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00655	EQU	*		else
* Useless label removed
* Line minilisp.c:998: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:989
* optim: remove16BitStackOperation
	LEAX	-12,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:998: for init
* Line minilisp.c:998: init of variable i
	CLRA
	LDB	#$01		1
	STD	-16,U		variable i
	BRA	L00659		jump to for condition
L00658	EQU	*
* Line minilisp.c:998: for body
* Line minilisp.c:998: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-12,U		address of array root_ADD_ROOT_
	LDD	-16,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:998: for increment(s)
	LDD	-16,U	
	ADDD	#1	
	STD	-16,U	
L00659	EQU	*
* Line minilisp.c:998: for condition
	LDD	-16,U		variable i
	CMPD	#$02	
	BLE	L00658	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:998: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-6,U		index 3 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:998: assignment: =
	LEAX	-12,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:998: init of variable params
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable params
* Line minilisp.c:998: init of variable body
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable body
* Line minilisp.c:999: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable params
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1000: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable body
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1001: return with value
* Line minilisp.c:1001: function call: make_function()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	10,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:989
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_make_function
	LEAS	10,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION inkey(): defined at /usr/local/share/cmoc/coco.h:356
_inkey	EQU	*
* Inline assembly:


        jsr [$A000]
        tfr a,b
    

* End of inline assembly.
* Useless label removed
	RTS
* END FUNCTION


*******************************************************************************

* FUNCTION intern(): defined at minilisp.c:599
_intern	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-10,S	
* Line minilisp.c:600: for init
* Line minilisp.c:600: init of variable p
	LDD	G00191+0,PCR	variable Symbols, declared at minilisp.c:112
	STD	-10,U		variable p
	BRA	L00663		jump to for condition
L00662	EQU	*
* Line minilisp.c:600: for body
* Line minilisp.c:601: if
* Line minilisp.c:601: function call: strcmp()
	LDX	-10,U		variable p
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LEAX	,X		member name of val
	TFR	X,D	
	PSHS	B,A		argument 2 of strcmp()
	LDD	6,U		variable name, declared at minilisp.c:599
	PSHS	B,A		argument 1 of strcmp()
	LBSR	_strcmp	
	LEAS	4,S	
	ADDD	#0	
	BNE	L00667	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:602: return with value
	LDX	-10,U		variable p
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	LBRA	L00127		return (minilisp.c:602)
L00667	EQU	*		else
* Useless label removed
* Useless label removed
* Line minilisp.c:600: for increment(s)
* Line minilisp.c:600: assignment: =
	LDX	-10,U		variable p
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	-10,U	
L00663	EQU	*
* Line minilisp.c:600: for condition
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-10,U		optim: optimize16BitCompares
	BNE	L00662		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:603: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:599
* optim: remove16BitStackOperation
	LEAX	-8,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:603: for init
* Line minilisp.c:603: init of variable i
	CLRA
	LDB	#$01		1
	STD	-10,U		variable i
	BRA	L00670		jump to for condition
L00669	EQU	*
* Line minilisp.c:603: for body
* Line minilisp.c:603: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-8,U		address of array root_ADD_ROOT_
	LDD	-10,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:603: for increment(s)
	LDD	-10,U	
	ADDD	#1	
	STD	-10,U	
L00670	EQU	*
* Line minilisp.c:603: for condition
	LDD	-10,U		variable i
	CMPD	#$01	
	BLE	L00669	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:603: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-4,U		index 2 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:603: assignment: =
	LEAX	-8,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:603: init of variable sym
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable sym
* Line minilisp.c:604: assignment: =
* Line minilisp.c:604: function call: make_symbol()
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:599
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_make_symbol
	LEAS	4,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable sym
* 
	STD	,X	
* Line minilisp.c:605: assignment: =
* Line minilisp.c:605: function call: cons()
	LEAX	G00191+0,PCR	variable Symbols, declared at minilisp.c:112
* optim: optimizePshsOps
	LDD	-2,U		variable sym, declared at minilisp.c:603
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:599
	PSHS	B,A		argument 1 of cons()
	LBSR	_cons	
	LEAS	6,S	
	STD	G00191+0,PCR
* Line minilisp.c:606: return with value
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
* optim: branchToNextLocation
L00127	EQU	*		end of intern()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION isLastSectorOfFile(): defined at /usr/local/share/cmoc/disk.h:542
_isLastSectorOfFile	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-3,S	
* Line /usr/local/share/cmoc/disk.h:544: init of variable fat
* Line /usr/local/share/cmoc/disk.h:544: function call: updateFAT()
	LBSR	_updateFAT
	STD	-3,U		variable fat
* Line /usr/local/share/cmoc/disk.h:545: if
* optim: storeLoad
	ADDD	#0	
	BNE	L00674	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:546: return with value
	CLRA
	LDB	#$01		decimal 1 signed
	BRA	L00089		return (/usr/local/share/cmoc/disk.h:546)
L00674	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:547: init of variable g
	LDX	-3,U		pointer fat
	PSHS	X		preserve array address, then eval array index
	LDX	4,U		variable fd
	LDB	8,X		member curGran of FileDesc
	CLRA			index expression is of byte type
	PULS	X		retrieve array address
* optimizeLoadDX
	LDB	D,X		get r-value
	STB	-1,U		variable g
* Line /usr/local/share/cmoc/disk.h:548: if
* optim: storeLoad
	CMPB	#$C1	
	BLO	L00677	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:549: if
	LDB	-1,U	
	CLRA
	ADDB	#$40		optim: changeAddDToAddB
* optim: stripExtraClrA_B
	PSHS	B		optim: stripPushLeas
	LDX	4,U		variable fd
	LDB	9,X		member curSec of FileDesc
* optim: stripExtraClrA_B
* optim: stripPushLeas1
	CMPB	,S+		compare with LSB
	BNE	L00680	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:550: return with value
	CLRA
	LDB	#$01		decimal 1 signed
	BRA	L00089		return (/usr/local/share/cmoc/disk.h:550)
L00680	EQU	*		else
* Useless label removed
L00677	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:551: return with value
	CLRA
	CLRB
* optim: branchToNextLocation
L00089	EQU	*		end of isLastSectorOfFile()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION is_list(): defined at minilisp.c:771
_is_list	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:772: return with value
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	4,U		optim: optimize16BitCompares
	BEQ	L00684		optim: optimize16BitCompares
	CLRB
	BRA	L00685		false
L00684	EQU	*
	LDB	#1	
L00685	EQU	*
	TSTB			||
	BNE	L00682		|| yields true
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[4,U]		optim: optimizeIndexedX
	CMPD	#2		optim: optimizeStackOperations1
	BEQ	L00686		if true
	CLRB
	BRA	L00687		false
L00686	EQU	*
	LDB	#1	
L00687	EQU	*
	TSTB			||
	BEQ	L00683	
L00682	EQU	*		|| at minilisp.c:772 yields true, B != 0
L00683	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION isalnum(): defined at minilisp.c:534
_isalnum	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:536: return with value
	LDB	5,U		variable c
	CMPB	#$30	
	BGE	L00693		if true
	CLRB
	BRA	L00694		false
L00693	EQU	*
	LDB	#1	
L00694	EQU	*
	TSTB			&&
	BEQ	L00692		&& at minilisp.c:535 yields false, B == 0
	LDB	5,U		variable c
	CMPB	#$39	
	BLE	L00695		if true
	CLRB
	BRA	L00696		false
L00695	EQU	*
	LDB	#1	
L00696	EQU	*
	TSTB			&&
	BEQ	L00692		&& at minilisp.c:535 yields false, B == 0
	LDB	#1		&& yields true
L00692	EQU	*
	TSTB			||
	BNE	L00690		|| yields true
	LDB	5,U		variable c
	CMPB	#$61	
	BGE	L00698		if true
	CLRB
	BRA	L00699		false
L00698	EQU	*
	LDB	#1	
L00699	EQU	*
	TSTB			&&
	BEQ	L00697		&& at minilisp.c:535 yields false, B == 0
	LDB	5,U		variable c
	CMPB	#$7A	
	BLE	L00700		if true
	CLRB
	BRA	L00701		false
L00700	EQU	*
	LDB	#1	
L00701	EQU	*
	TSTB			&&
	BEQ	L00697		&& at minilisp.c:535 yields false, B == 0
	LDB	#1		&& yields true
L00697	EQU	*
	TSTB			||
	BEQ	L00691	
L00690	EQU	*		|| at minilisp.c:535 yields true, B != 0
L00691	EQU	*
	TSTB			||
	BNE	L00688		|| yields true
	LDB	5,U		variable c
	CMPB	#$41	
	BGE	L00703		if true
	CLRB
	BRA	L00704		false
L00703	EQU	*
	LDB	#1	
L00704	EQU	*
	TSTB			&&
	BEQ	L00702		&& at minilisp.c:536 yields false, B == 0
	LDB	5,U		variable c
	CMPB	#$5A	
	BLE	L00705		if true
	CLRB
	BRA	L00706		false
L00705	EQU	*
	LDB	#1	
L00706	EQU	*
	TSTB			&&
	BEQ	L00702		&& at minilisp.c:536 yields false, B == 0
	LDB	#1		&& yields true
L00702	EQU	*
	TSTB			||
	BEQ	L00689	
L00688	EQU	*		|| at minilisp.c:536 yields true, B != 0
L00689	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION isalpha(): defined at minilisp.c:539
_isalpha	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:540: return with value
	LDB	5,U		variable c
	CMPB	#$61	
	BGE	L00710		if true
	CLRB
	BRA	L00711		false
L00710	EQU	*
	LDB	#1	
L00711	EQU	*
	TSTB			&&
	BEQ	L00709		&& at minilisp.c:540 yields false, B == 0
	LDB	5,U		variable c
	CMPB	#$7A	
	BLE	L00712		if true
	CLRB
	BRA	L00713		false
L00712	EQU	*
	LDB	#1	
L00713	EQU	*
	TSTB			&&
	BEQ	L00709		&& at minilisp.c:540 yields false, B == 0
	LDB	#1		&& yields true
L00709	EQU	*
	TSTB			||
	BNE	L00707		|| yields true
	LDB	5,U		variable c
	CMPB	#$41	
	BGE	L00715		if true
	CLRB
	BRA	L00716		false
L00715	EQU	*
	LDB	#1	
L00716	EQU	*
	TSTB			&&
	BEQ	L00714		&& at minilisp.c:540 yields false, B == 0
	LDB	5,U		variable c
	CMPB	#$5A	
	BLE	L00717		if true
	CLRB
	BRA	L00718		false
L00717	EQU	*
	LDB	#1	
L00718	EQU	*
	TSTB			&&
	BEQ	L00714		&& at minilisp.c:540 yields false, B == 0
	LDB	#1		&& yields true
L00714	EQU	*
	TSTB			||
	BEQ	L00708	
L00707	EQU	*		|| at minilisp.c:540 yields true, B != 0
L00708	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION isdigit(): defined at minilisp.c:530
_isdigit	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:531: return with value
	LDB	5,U		variable c
	CMPB	#$30	
	BGE	L00720		if true
	CLRB
	BRA	L00721		false
L00720	EQU	*
	LDB	#1	
L00721	EQU	*
	TSTB			&&
	BEQ	L00719		&& at minilisp.c:531 yields false, B == 0
	LDB	5,U		variable c
	CMPB	#$39	
	BLE	L00722		if true
	CLRB
	BRA	L00723		false
L00722	EQU	*
	LDB	#1	
L00723	EQU	*
	TSTB			&&
	BEQ	L00719		&& at minilisp.c:531 yields false, B == 0
	LDB	#1		&& yields true
L00719	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION length(): defined at minilisp.c:706
_length	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:707: init of variable len
	CLRA
	CLRB
	STD	-2,U		variable len
	BRA	L00725		jump to for condition
L00724	EQU	*
* Line minilisp.c:708: for body
	LEAX	-2,U		variable len, declared at minilisp.c:707
	LDD	,X	
	ADDD	#1	
	STD	,X	
* optim: removeUselessOps
* Useless label removed
* Line minilisp.c:708: for increment(s)
* Line minilisp.c:708: assignment: =
	LDX	4,U		variable list
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	4,U	
L00725	EQU	*
* Line minilisp.c:708: for condition
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[4,U]		optim: optimizeIndexedX
	CMPD	#2		optim: optimizeStackOperations1
	BEQ	L00724	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:710: return with value
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	4,U		optim: optimize16BitCompares
	BEQ	L00728		optim: optimize16BitCompares
	CLRB
	BRA	L00729		false
L00728	EQU	*
	LDB	#1	
L00729	EQU	*
	TSTB
	BEQ	L00730		if conditional expression is false
	LDD	-2,U		variable len, declared at minilisp.c:707
	BRA	L00731		end of true expression of conditional
L00730	EQU	*
	LDD	#$FFFF		constant expression: 65535 decimal
L00731	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION longjmp(): defined at setjmp.c:21
_longjmp	EQU	*
* Inline assembly:


    ldd 4,s
    ldx 2,s
    lds 2,x
    ldu 4,x
    bne longjmp_rts
    ldb #1
longjmp_rts:
    jmp [,x]
  

* End of inline assembly.
* Useless label removed
	RTS
* END FUNCTION


*******************************************************************************

* FUNCTION macroexpand(): defined at minilisp.c:811
_macroexpand	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-18,S	
* Line minilisp.c:812: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BNE	L00732	
* optim: branchToNextLocation
* Useless label removed
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BEQ	L00733	
* optim: condBranchOverUncondBranch
L00732	EQU	*		then
* Line minilisp.c:813: return with value
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	LBRA	L00144		return (minilisp.c:813)
L00733	EQU	*		else
* Useless label removed
* Line minilisp.c:814: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:811
* optim: remove16BitStackOperation
	LEAX	-16,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:814: for init
* Line minilisp.c:814: init of variable i
	CLRA
	LDB	#$01		1
	STD	-18,U		variable i
	BRA	L00737		jump to for condition
L00736	EQU	*
* Line minilisp.c:814: for body
* Line minilisp.c:814: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-16,U		address of array root_ADD_ROOT_
	LDD	-18,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:814: for increment(s)
	LDD	-18,U	
	ADDD	#1	
	STD	-18,U	
L00737	EQU	*
* Line minilisp.c:814: for condition
	LDD	-18,U		variable i
	CMPD	#$03	
	BLE	L00736	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:814: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-8,U		index 4 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:814: assignment: =
	LEAX	-16,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:814: init of variable bind
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-6,U		variable bind
* Line minilisp.c:814: init of variable macro
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable macro
* Line minilisp.c:814: init of variable args
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable args
* Line minilisp.c:815: assignment: =
* Line minilisp.c:815: function call: find()
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDX	,X		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:811
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_find	
	LEAS	4,S	
* optim: pushDLoadXLoadD
	LDX	-6,U		indirection of variable bind
* 
	STD	,X	
* Line minilisp.c:816: if
* optim: optimizeIndexedX
	LDD	[-6,U]		optim: optimizeIndexedX
* optim: loadCmpZeroBeqOrBne
	BEQ	L00740	
* optim: condBranchOverUncondBranch
* Useless label removed
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[-6,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BEQ	L00741	
* optim: condBranchOverUncondBranch
L00740	EQU	*		then
* Line minilisp.c:817: return with value
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	BRA	L00144		return (minilisp.c:817)
L00741	EQU	*		else
* Useless label removed
* Line minilisp.c:818: assignment: =
* optim: optimizeIndexedX
	LDD	[-6,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable macro
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:819: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable args
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:820: return with value
* Line minilisp.c:820: function call: apply_func()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:811
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_apply_func
	LEAS	8,S	
* optim: branchToNextLocation
L00144	EQU	*		end of macroexpand()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION main(): defined at minilisp.c:1218
_main	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-56,S	
* Line minilisp.c:1219: function call: width()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		argument 1 of width()
	LBSR	_width	
	LEAS	2,S	
* Line minilisp.c:1220: function call: printf()
	LEAX	S00309,PCR	"COLOR COMPUTER MINILISP\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1221: function call: printf()
	LEAX	S00310,PCR	"ORIGINAL BY RUI UEYAMA\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1222: function call: printf()
	LEAX	S00311,PCR	"COCO PORT: JAMIE CHO\n\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1223: function call: printf()
	LEAX	S00312,PCR	"PRESS <BREAK> TO EVAL COMMANDS\n\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1226: assignment: =
	LEAX	G00192+0,PCR	address of array memory1
* optim: optimizeTfrOp
	STX	G00194+0,PCR	optim: optimizeTfrOp
* Line minilisp.c:1230: assignment: =
	LEAX	-54,U		variable trueObj, declared at minilisp.c:1229
* optim: optimizeTfrOp
	STX	G00187+0,PCR	optim: optimizeTfrOp
* Line minilisp.c:1231: assignment: =
	LEAX	-44,U		variable nilObj, declared at minilisp.c:1229
* optim: optimizeTfrOp
	STX	G00188+0,PCR	optim: optimizeTfrOp
* Line minilisp.c:1232: assignment: =
	LEAX	-34,U		variable dotObj, declared at minilisp.c:1229
* optim: optimizeTfrOp
	STX	G00189+0,PCR	optim: optimizeTfrOp
* Line minilisp.c:1233: assignment: =
	LEAX	-24,U		variable cparenObj, declared at minilisp.c:1229
* optim: optimizeTfrOp
	STX	G00190+0,PCR	optim: optimizeTfrOp
* Line minilisp.c:1234: assignment: =
	CLRA
	LDB	#$09		decimal 9 signed
* optim: pushDLoadXLoadD
	LDX	G00187+0,PCR	variable True
* 
	STD	,X	
* Line minilisp.c:1235: assignment: =
* LDD #$0A optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LDX	G00188+0,PCR	variable Nil
	LDB	#10		optim: removeAndOrMulAddSub
	STD	,X	
* Line minilisp.c:1236: assignment: =
* LDD #$0B optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LDX	G00189+0,PCR	variable Dot
	LDB	#11		optim: removeAndOrMulAddSub
	STD	,X	
* Line minilisp.c:1237: assignment: =
* LDD #$0C optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LDX	G00190+0,PCR	variable Cparen
	LDB	#12		optim: removeAndOrMulAddSub
	STD	,X	
* Line minilisp.c:1240: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	G00188+0,PCR
	STD	G00191+0,PCR
* Line minilisp.c:1241: init of variable root
	CLRA
	CLRB
	STD	-14,U		variable root
* Line minilisp.c:1242: assignment: =
* optim: storeLoad
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-12,U		index 0 in array root_ADD_ROOT_[]
	LDB	#0		optim: removeAndOrMulAddSub
	STD	,X	
* Line minilisp.c:1242: for init
* Line minilisp.c:1242: init of variable i
* optim: removeClr
	LDB	#$01		1
	STD	-56,U		variable i
	BRA	L00745		jump to for condition
L00744	EQU	*
* Line minilisp.c:1242: for body
* Line minilisp.c:1242: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-12,U		address of array root_ADD_ROOT_
	LDD	-56,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:1242: for increment(s)
	LDD	-56,U	
	ADDD	#1	
	STD	-56,U	
L00745	EQU	*
* Line minilisp.c:1242: for condition
	LDD	-56,U		variable i
	CMPD	#$02	
	BLE	L00744	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:1242: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-6,U		index 3 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1242: assignment: =
	LEAX	-12,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	-14,U		optim: optimizeTfrOp
* Line minilisp.c:1242: init of variable env
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable env
* Line minilisp.c:1242: init of variable expr
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable expr
* Line minilisp.c:1243: assignment: =
* Line minilisp.c:1243: function call: make_env()
	LEAY	G00188+0,PCR	optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LEAX	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimizePshsOps
	LDD	-14,U		variable root, declared at minilisp.c:1241
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_make_env
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-4,U		indirection of variable env
* 
	STD	,X	
* Line minilisp.c:1244: function call: define_constants()
	LDX	-4,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-14,U		variable root, declared at minilisp.c:1241
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_define_constants
	LEAS	4,S	
* Line minilisp.c:1245: function call: define_primitives()
	LDX	-4,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-14,U		variable root, declared at minilisp.c:1241
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_define_primitives
	LEAS	4,S	
* Line minilisp.c:1248: function call: setjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of setjmp()
	LBSR	_setjmp	
	LEAS	2,S	
* Line minilisp.c:1249: assignment: =
	CLRA
	CLRB
* optim: removeClr
	STB	G00209+0,PCR
* Line minilisp.c:1250: if
	LDB	G00207+0,PCR	variable doing_load, declared at minilisp.c:429
* optim: loadCmpZeroBeqOrBne
	BEQ	L00749	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1251: assignment: =
	CLRA
	CLRB
* optim: removeClr
	STB	G00207+0,PCR
* Line minilisp.c:1252: function call: close()
	LEAX	G00208+0,PCR	variable fd, declared at minilisp.c:430
	PSHS	X		argument 1 of close()
	LBSR	_close	
	LEAS	2,S	
L00749	EQU	*		else
* Useless label removed
L00751	EQU	*
* Line minilisp.c:1254: for body
* Line minilisp.c:1255: assignment: =
* Line minilisp.c:1255: function call: read_expr()
	LDD	-14,U		variable root, declared at minilisp.c:1241
	PSHS	B,A		argument 1 of read_expr()
	LBSR	_read_expr
	LEAS	2,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable expr
* 
	STD	,X	
* Line minilisp.c:1256: if
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
* optim: loadCmpZeroBeqOrBne
	BNE	L00756	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:1257: return with value
	CLRA
	CLRB
	LBRA	L00178		return (minilisp.c:1257)
L00756	EQU	*		else
* Useless label removed
* Line minilisp.c:1258: if
	LDD	G00190+0,PCR	variable Cparen, declared at minilisp.c:108
	PSHS	B,A	
	LDX	-2,U		indirection of variable expr
	LDD	,X		indirection
	CMPD	,S++	
	BNE	L00759	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1259: function call: printf()
	LEAX	S00313,PCR	"STRAY CLOSE PARENTHESIS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1259: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00759	EQU	*		else
* Useless label removed
* Line minilisp.c:1260: if
	LDD	G00189+0,PCR	variable Dot, declared at minilisp.c:107
	PSHS	B,A	
	LDX	-2,U		indirection of variable expr
	LDD	,X		indirection
	CMPD	,S++	
	BNE	L00762	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1261: function call: printf()
	LEAX	S00314,PCR	"STRAY DOT\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1261: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00762	EQU	*		else
* Useless label removed
* Line minilisp.c:1262: function call: print()
* Line minilisp.c:1262: function call: eval()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-4,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-14,U		variable root, declared at minilisp.c:1241
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
	PSHS	B,A		argument 1 of print()
	LBSR	_print	
	LEAS	2,S	
* Line minilisp.c:1263: function call: printf()
	LEAX	S00228,PCR	"\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Useless label removed
	LBRA	L00751	
* Useless label removed
L00178	EQU	*		end of main()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION make_env(): defined at minilisp.c:374
_make_env	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:375: init of variable r
* Line minilisp.c:375: function call: alloc()
	LDY	#$04		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	#$07		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:374
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_alloc	
	LEAS	6,S	
	STD	-2,U		variable r
* Line minilisp.c:376: assignment: =
* optim: optimizeIndexedX
	LDD	[6,U]		optim: optimizeIndexedX
* optim: remove16BitStackOperation
	LDX	-2,U		variable r
	LEAX	4,X		member val of Obj
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:377: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
* optim: remove16BitStackOperation
	LDX	-2,U		variable r
	LEAX	4,X		member val of Obj
	LEAX	2,X		member up of env
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:378: return with value
	LDD	-2,U		variable r, declared at minilisp.c:375
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION make_function(): defined at minilisp.c:365
_make_function	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:366: do-while
* Useless label removed
* Line minilisp.c:366: if
	LDD	8,U		variable type
	CMPD	#$05	
	BEQ	L00768	
* optim: branchToNextLocation
* Useless label removed
	LDD	8,U		variable type
	CMPD	#$06	
	BEQ	L00768	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:366: function call: printf()
	LEAX	S00226,PCR	"type == TFUNCTION || type == TMACRO"
* optim: optimizePshsOps
	LDD	#$016E		decimal 366 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAY	S00222,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	S00211,PCR	"***ASSERT FAILED: %s:%u: %s\n"
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_printf	
	LEAS	8,S	
L00771	EQU	*
* Line minilisp.c:366: for body
* Useless label removed
	BRA	L00771	
* Useless label removed
L00768	EQU	*		else
* Useless label removed
* Useless label removed
* Line minilisp.c:367: init of variable r
* Line minilisp.c:367: function call: alloc()
	LDY	#$06		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	8,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:365
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_alloc	
	LEAS	6,S	
	STD	-2,U		variable r
* Line minilisp.c:368: assignment: =
* optim: optimizeIndexedX
	LDD	[10,U]		optim: optimizeIndexedX
* optim: remove16BitStackOperation
	LDX	-2,U		variable r
	LEAX	4,X		member val of Obj
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:369: assignment: =
* optim: optimizeIndexedX
	LDD	[12,U]		optim: optimizeIndexedX
* optim: remove16BitStackOperation
	LDX	-2,U		variable r
	LEAX	4,X		member val of Obj
	LEAX	2,X		member body of func
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:370: assignment: =
* optim: optimizeIndexedX
	LDD	[6,U]		optim: optimizeIndexedX
* optim: remove16BitStackOperation
	LDX	-2,U		variable r
	LEAX	4,X		member val of Obj
	LEAX	4,X		member env of func
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:371: return with value
	LDD	-2,U		variable r, declared at minilisp.c:367
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION make_int(): defined at minilisp.c:340
_make_int	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:341: init of variable r
* Line minilisp.c:341: function call: alloc()
	LDY	#$02		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	#$01		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:340
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_alloc	
	LEAS	6,S	
	STD	-2,U		variable r
* Line minilisp.c:342: assignment: =
	LDD	6,U		variable value, declared at minilisp.c:340
* optim: remove16BitStackOperation
	LDX	-2,U		variable r
	LEAX	4,X		member val of Obj
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:343: return with value
	LDD	-2,U		variable r, declared at minilisp.c:341
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION make_primitive(): defined at minilisp.c:359
_make_primitive	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:360: init of variable r
* Line minilisp.c:360: function call: alloc()
	LDY	#$02		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	#$04		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:359
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_alloc	
	LEAS	6,S	
	STD	-2,U		variable r
* Line minilisp.c:361: assignment: =
	LDD	6,U		variable fn, declared at minilisp.c:359
* optim: remove16BitStackOperation
	LDX	-2,U		variable r
	LEAX	4,X		member val of Obj
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:362: return with value
	LDD	-2,U		variable r, declared at minilisp.c:360
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION make_symbol(): defined at minilisp.c:353
_make_symbol	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:354: init of variable sym
* Line minilisp.c:354: function call: alloc()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A	
* Line minilisp.c:354: function call: strlen()
	LDD	6,U		variable name, declared at minilisp.c:353
	PSHS	B,A		argument 1 of strlen()
	LBSR	_strlen	
	LEAS	2,S	
	ADDD	,S++	
	PSHS	B,A		argument 3 of alloc()
	LDX	#$03		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:353
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_alloc	
	LEAS	6,S	
	STD	-2,U		variable sym
* Line minilisp.c:355: function call: strcpy()
	LDD	6,U		variable name, declared at minilisp.c:353
	PSHS	B,A		argument 2 of strcpy()
	LDX	-2,U		variable sym
	LEAX	4,X		member val of Obj
	LEAX	,X		member name of val
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strcpy	
	LEAS	4,S	
* Line minilisp.c:356: return with value
	LDD	-2,U		variable sym, declared at minilisp.c:354
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION normalizeFilename(): defined at /usr/local/share/cmoc/disk.h:672
_normalizeFilename	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-3,S	
* Line /usr/local/share/cmoc/disk.h:674: init of variable reader
	LDD	6,U		variable src, declared at /usr/local/share/cmoc/disk.h:672
	STD	-3,U		variable reader
* Line /usr/local/share/cmoc/disk.h:676: for init
* Line /usr/local/share/cmoc/disk.h:676: assignment: =
	CLRA
	CLRB
* optim: removeClr
	STB	-1,U	
	LBRA	L00776		jump to for condition
L00775	EQU	*
* Line /usr/local/share/cmoc/disk.h:676: for body
* Line /usr/local/share/cmoc/disk.h:678: if
	LDB	#$2E		optim: lddToLDB
	SEX			promotion of binary operand
	PSHS	B		optim: stripPushLeas
	LDX	-3,U		indirection of variable reader
	LDB	,X		indirection
	SEX			promotion of binary operand
* optim: stripPushLeas1
	CMPB	,S+		compare with LSB
	BNE	L00780	
* optim: condBranchOverUncondBranch
* Useless label removed
	LEAX	-3,U		variable reader, declared at /usr/local/share/cmoc/disk.h:674
	LDD	,X	
	ADDD	#1	
	STD	,X	
	BRA	L00778		break
L00780	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:683: if
* optim: optimizeIndexedX
	LDB	[-3,U]		optim: optimizeIndexedX
* optim: loadCmpZeroBeqOrBne
	BNE	L00783	
* optim: condBranchOverUncondBranch
* Useless label removed
	BRA	L00778		break
L00783	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:685: assignment: =
* Line /usr/local/share/cmoc/disk.h:685: function call: toupper()
	LDX	-3,U		indirection of variable reader
	LDB	,X		indirection
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of toupper()
	LBSR	_toupper
	LEAS	2,S	
* optim: stripExtraPushPullB
	LDX	4,U		indirection of variable dest
* optim: stripExtraPushPullB
	STB	,X	
	LEAX	4,U		variable dest, declared at /usr/local/share/cmoc/disk.h:672
	LDD	,X	
	ADDD	#1	
	STD	,X	
	LEAX	-3,U		variable reader, declared at /usr/local/share/cmoc/disk.h:674
	LDD	,X	
	ADDD	#1	
	STD	,X	
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:676: for increment(s)
	INC	-1,U	
L00776	EQU	*
* Line /usr/local/share/cmoc/disk.h:676: for condition
	LDB	-1,U		variable i
	CMPB	#$08	
	LBLO	L00775	
* optim: branchToNextLocation
L00778	EQU	*		end for
* Line /usr/local/share/cmoc/disk.h:689: if
	LDB	-1,U		variable i
	CMPB	#$08	
	LBNE	L00786	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:692: while
L00789	EQU	*		while condition at /usr/local/share/cmoc/disk.h:692
* optim: optimizeIndexedX
	LDB	[-3,U]		optim: optimizeIndexedX
* optim: loadCmpZeroBeqOrBne
	BEQ	L00790	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	#$2E		optim: lddToLDB
	SEX			promotion of binary operand
	PSHS	B		optim: stripPushLeas
	LDX	-3,U		indirection of variable reader
	LDB	,X		indirection
	SEX			promotion of binary operand
* optim: stripPushLeas1
	CMPB	,S+		compare with LSB
	BEQ	L00790	
* optim: condBranchOverUncondBranch
* Useless label removed
	LEAX	-3,U		variable reader, declared at /usr/local/share/cmoc/disk.h:674
	LDD	,X	
	ADDD	#1	
	STD	,X	
	BRA	L00789		go to while condition
L00790	EQU	*		after end of while starting at /usr/local/share/cmoc/disk.h:692
* Line /usr/local/share/cmoc/disk.h:694: if
	LDB	#$2E		optim: lddToLDB
	SEX			promotion of binary operand
	PSHS	B		optim: stripPushLeas
	LDX	-3,U		indirection of variable reader
	LDB	,X		indirection
	SEX			promotion of binary operand
* optim: stripPushLeas1
	CMPB	,S+		compare with LSB
	BNE	L00793	
* optim: condBranchOverUncondBranch
* Useless label removed
	LEAX	-3,U		variable reader, declared at /usr/local/share/cmoc/disk.h:674
	LDD	,X	
	ADDD	#1	
	STD	,X	
L00793	EQU	*		else
* Useless label removed
	BRA	L00787		jump over else clause
L00786	EQU	*		else
* Line /usr/local/share/cmoc/disk.h:698: while
L00796	EQU	*		while condition at /usr/local/share/cmoc/disk.h:698
	LDB	-1,U		variable i
	CMPB	#$08	
	BHS	L00797	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:700: assignment: =
	CLRA
* LDB #$20 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDX	4,U		get pointer dest
	LDB	#32		optimiz: optimizePostIncrement
* optimiz: optimizePostIncrement
	STB	,X+		optimiz: optimizePostIncrement
* optimiz: optimizePostIncrement
	STX	4,U		optimiz: optimizePostIncrement
	LEAX	-1,U		variable i, declared at /usr/local/share/cmoc/disk.h:675
	INC	,X	
	LDB	,X	
	BRA	L00796		go to while condition
L00797	EQU	*		after end of while starting at /usr/local/share/cmoc/disk.h:698
L00787	EQU	*		end if
* Line /usr/local/share/cmoc/disk.h:703: for init
* Line /usr/local/share/cmoc/disk.h:703: assignment: =
	CLRA
	CLRB
* optim: removeClr
	STB	-1,U	
	BRA	L00799		jump to for condition
L00798	EQU	*
* Line /usr/local/share/cmoc/disk.h:703: for body
* Line /usr/local/share/cmoc/disk.h:705: if
* optim: optimizeIndexedX
	LDB	[-3,U]		optim: optimizeIndexedX
* optim: loadCmpZeroBeqOrBne
	BNE	L00803	
* optim: condBranchOverUncondBranch
* Useless label removed
	BRA	L00801		break
L00803	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:707: assignment: =
* Line /usr/local/share/cmoc/disk.h:707: function call: toupper()
	LDX	-3,U		indirection of variable reader
	LDB	,X		indirection
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of toupper()
	LBSR	_toupper
	LEAS	2,S	
* optim: stripExtraPushPullB
	LDX	4,U		indirection of variable dest
* optim: stripExtraPushPullB
	STB	,X	
	LEAX	-3,U		variable reader, declared at /usr/local/share/cmoc/disk.h:674
	LDD	,X	
	ADDD	#1	
	STD	,X	
	LEAX	4,U		variable dest, declared at /usr/local/share/cmoc/disk.h:672
	LDD	,X	
	ADDD	#1	
	STD	,X	
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:703: for increment(s)
	INC	-1,U	
L00799	EQU	*
* Line /usr/local/share/cmoc/disk.h:703: for condition
	LDB	-1,U		variable i
	CMPB	#$03	
	BLO	L00798	
* optim: branchToNextLocation
L00801	EQU	*		end for
* Line /usr/local/share/cmoc/disk.h:711: while
L00806	EQU	*		while condition at /usr/local/share/cmoc/disk.h:711
	LDB	-1,U		variable i
	CMPB	#$03	
	BHS	L00807	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:713: assignment: =
	CLRA
* LDB #$20 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDX	4,U		get pointer dest
	LDB	#32		optimiz: optimizePostIncrement
* optimiz: optimizePostIncrement
	STB	,X+		optimiz: optimizePostIncrement
* optimiz: optimizePostIncrement
	STX	4,U		optimiz: optimizePostIncrement
	LEAX	-1,U		variable i, declared at /usr/local/share/cmoc/disk.h:675
	INC	,X	
	LDB	,X	
	BRA	L00806		go to while condition
L00807	EQU	*		after end of while starting at /usr/local/share/cmoc/disk.h:711
* Line /usr/local/share/cmoc/disk.h:716: assignment: =
	CLRA
	CLRB
* optim: stripExtraPushPullB
	LDX	4,U		indirection of variable dest
* optim: stripExtraPushPullB
	STB	,X	
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION open(): defined at /usr/local/share/cmoc/disk.h:155
_open	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-21,S	
* Line /usr/local/share/cmoc/disk.h:157: if
	LDD	4,U		variable fd, declared at /usr/local/share/cmoc/disk.h:155
* optim: loadCmpZeroBeqOrBne
	BEQ	L00808	
* optim: branchToNextLocation
* Useless label removed
	LDD	6,U		variable filename, declared at /usr/local/share/cmoc/disk.h:155
* optim: loadCmpZeroBeqOrBne
	BNE	L00809	
* optim: condBranchOverUncondBranch
L00808	EQU	*		then
* Line /usr/local/share/cmoc/disk.h:158: return with value
	CLRA
	CLRB
	LBRA	L00078		return (/usr/local/share/cmoc/disk.h:158)
L00809	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:160: do-while
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:160: if
	LDX	4,U		variable fd
	LEAX	18,X		member curSector of FileDesc
	TFR	X,D	
	ADDD	#0	
	BNE	L00816	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:160: function call: printf()
	LEAX	S00213,PCR	"fd->curSector != 0"
* optim: optimizePshsOps
	CLRA
	LDB	#$A0		decimal 160 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LEAY	S00212,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	S00211,PCR	"***ASSERT FAILED: %s:%u: %s\n"
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_printf	
	LEAS	8,S	
L00818	EQU	*
* Line /usr/local/share/cmoc/disk.h:160: for body
* Useless label removed
	BRA	L00818	
* Useless label removed
L00816	EQU	*		else
* Useless label removed
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:163: if
* Line /usr/local/share/cmoc/disk.h:163: function call: findDirEntry()
	LDD	6,U		variable filename, declared at /usr/local/share/cmoc/disk.h:155
	PSHS	B,A		argument 2 of findDirEntry()
	LEAX	-21,U		address of array dirEntry
	PSHS	X		argument 1 of findDirEntry()
	LBSR	_findDirEntry
	LEAS	4,S	
	TSTB
	BNE	L00823	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:164: return with value
	CLRA
	CLRB
	LBRA	L00078		return (/usr/local/share/cmoc/disk.h:164)
L00823	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:166: init of variable fat
* Line /usr/local/share/cmoc/disk.h:166: function call: updateFAT()
	LBSR	_updateFAT
	STD	-5,U		variable fat
* Line /usr/local/share/cmoc/disk.h:167: if
* optim: storeLoad
	ADDD	#0	
	BNE	L00826	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:168: return with value
	CLRA
	CLRB
	LBRA	L00078		return (/usr/local/share/cmoc/disk.h:168)
L00826	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:170: init of variable firstGran
	LDB	-8,U		index 13 in array dirEntry[]
	STB	-3,U		variable firstGran
* Line /usr/local/share/cmoc/disk.h:171: init of variable numBytesLastSector
	LEAX	-21,U		array dirEntry
	TFR	X,D	
	ADDD	#$0E		14
	TFR	D,X	
	LDD	,X		indirection
	STD	-2,U		variable numBytesLastSector
* Line /usr/local/share/cmoc/disk.h:173: assignment: =
	LDB	G00183+0,PCR	variable curDriveNo, declared at /usr/local/share/cmoc/disk.h:138
* optim: stripExtraPushPullB
	LDX	4,U		variable fd
* optim: stripExtraPushPullB
	STB	,X	
* Line /usr/local/share/cmoc/disk.h:174: assignment: =
	LDB	-3,U		variable firstGran, declared at /usr/local/share/cmoc/disk.h:170
* optim: stripExtraPushPullB
	LDX	4,U		variable fd
	LEAX	1,X		member firstGran of FileDesc
* optim: stripExtraPushPullB
	STB	,X	
* Line /usr/local/share/cmoc/disk.h:175: assignment: =
	LDD	-2,U		variable numBytesLastSector, declared at /usr/local/share/cmoc/disk.h:171
* optim: remove16BitStackOperation
	LDX	4,U		variable fd
	LEAX	2,X		member numBytesLastSector of FileDesc
* optim: remove16BitStackOperation
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:176: function call: computeFileLength()
	LDX	4,U		variable fd
	LDD	2,X		member numBytesLastSector of FileDesc
	PSHS	B,A		argument 3 of computeFileLength()
* optim: removeUselessLdx
	LDB	1,X		member firstGran of FileDesc
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of computeFileLength()
* optim: removeUselessLdx
	LEAX	4,X		member length of FileDesc
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_computeFileLength
	LEAS	6,S	
* Line /usr/local/share/cmoc/disk.h:178: function call: rewind()
	LDD	4,U		variable fd, declared at /usr/local/share/cmoc/disk.h:155
	PSHS	B,A		argument 1 of rewind()
	LBSR	_rewind	
	LEAS	2,S	
* Line /usr/local/share/cmoc/disk.h:180: return with value
	CLRA
	LDB	#$01		decimal 1 signed
* optim: branchToNextLocation
L00078	EQU	*		end of open()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION peek(): defined at minilisp.c:543
_peek	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-1,S	
* Line minilisp.c:544: init of variable c
* Line minilisp.c:544: function call: getchar()
	LBSR	_getchar
	STB	-1,U		variable c
* Line minilisp.c:545: function call: ungetc()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		argument 2 of ungetc()
	LDB	-1,U		variable c, declared at minilisp.c:544
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of ungetc()
	LBSR	_ungetc	
	LEAS	4,S	
* Line minilisp.c:546: return with value
	LDB	-1,U		variable c, declared at minilisp.c:544
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_car(): defined at minilisp.c:879
_prim_car	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:880: init of variable args
* Line minilisp.c:880: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:879
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-2,U		variable args
* Line minilisp.c:881: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-2,U		variable args
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	,X		member type of Obj
	CMPD	#2		optim: optimizeStackOperations1
	BNE	L00828	
* optim: branchToNextLocation
* Useless label removed
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	PSHS	B,A	
	LDX	-2,U		variable args
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	CMPD	,S++	
	BEQ	L00829	
* optim: condBranchOverUncondBranch
L00828	EQU	*		then
* Line minilisp.c:882: function call: printf()
	LEAX	S00256,PCR	"MALFORMED CAR\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:882: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00829	EQU	*		else
* Useless label removed
* Line minilisp.c:883: return with value
	LDX	-2,U		variable args
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_cdr(): defined at minilisp.c:887
_prim_cdr	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:888: init of variable args
* Line minilisp.c:888: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:887
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-2,U		variable args
* Line minilisp.c:889: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-2,U		variable args
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	,X		member type of Obj
	CMPD	#2		optim: optimizeStackOperations1
	BNE	L00832	
* optim: branchToNextLocation
* Useless label removed
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	PSHS	B,A	
	LDX	-2,U		variable args
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	CMPD	,S++	
	BEQ	L00833	
* optim: condBranchOverUncondBranch
L00832	EQU	*		then
* Line minilisp.c:890: function call: printf()
	LEAX	S00257,PCR	"MALFORMED CDR\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:890: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00833	EQU	*		else
* Useless label removed
* Line minilisp.c:891: return with value
	LDX	-2,U		variable args
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_cons(): defined at minilisp.c:870
_prim_cons	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:871: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:871: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L00837	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:872: function call: printf()
	LEAX	S00255,PCR	"MALFORMED CONS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:872: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00837	EQU	*		else
* Useless label removed
* Line minilisp.c:873: init of variable cell
* Line minilisp.c:873: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:870
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-2,U		variable cell
* Line minilisp.c:874: assignment: =
	LDX	-2,U		variable cell
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-2,U		variable cell
	LEAX	4,X		member val of Obj
	LEAX	2,X		member cdr of cell
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:875: return with value
	LDD	-2,U		variable cell, declared at minilisp.c:873
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_define(): defined at minilisp.c:1026
_prim_define	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-14,S	
* Line minilisp.c:1027: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:1027: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BNE	L00839	
* optim: branchToNextLocation
* Useless label removed
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BEQ	L00840	
* optim: condBranchOverUncondBranch
L00839	EQU	*		then
* Line minilisp.c:1028: function call: printf()
	LEAX	S00270,PCR	"MALFORMED DEFINE\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1028: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00840	EQU	*		else
* Useless label removed
* Line minilisp.c:1029: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:1026
* optim: remove16BitStackOperation
	LEAX	-12,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1029: for init
* Line minilisp.c:1029: init of variable i
	CLRA
	LDB	#$01		1
	STD	-14,U		variable i
	BRA	L00844		jump to for condition
L00843	EQU	*
* Line minilisp.c:1029: for body
* Line minilisp.c:1029: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-12,U		address of array root_ADD_ROOT_
	LDD	-14,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:1029: for increment(s)
	LDD	-14,U	
	ADDD	#1	
	STD	-14,U	
L00844	EQU	*
* Line minilisp.c:1029: for condition
	LDD	-14,U		variable i
	CMPD	#$02	
	BLE	L00843	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:1029: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-6,U		index 3 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1029: assignment: =
	LEAX	-12,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:1029: init of variable sym
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable sym
* Line minilisp.c:1029: init of variable value
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable value
* Line minilisp.c:1030: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable sym
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1031: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable value
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1032: assignment: =
* Line minilisp.c:1032: function call: eval()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1026
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable value
* 
	STD	,X	
* Line minilisp.c:1033: function call: add_variable()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1026
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_add_variable
	LEAS	8,S	
* Line minilisp.c:1034: return with value
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_defmacro(): defined at minilisp.c:1038
_prim_defmacro	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:1039: return with value
* Line minilisp.c:1039: function call: handle_defun()
	LDY	#$06		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1038
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_handle_defun
	LEAS	8,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_defun(): defined at minilisp.c:1021
_prim_defun	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:1022: return with value
* Line minilisp.c:1022: function call: handle_defun()
	LDY	#$05		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1021
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_handle_defun
	LEAS	8,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_eq(): defined at minilisp.c:1136
_prim_eq	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line minilisp.c:1137: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:1137: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L00848	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1138: function call: printf()
	LEAX	S00282,PCR	"MALFORMED EQ\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1138: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00848	EQU	*		else
* Useless label removed
* Line minilisp.c:1139: init of variable values
* Line minilisp.c:1139: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1136
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-2,U		variable values
* Line minilisp.c:1140: return with value
	LDX	-2,U		variable values
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	PSHS	B,A	
	LDX	-2,U		variable values
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	CMPD	,S++	
	BEQ	L00850		if true
	CLRB
	BRA	L00851		false
L00850	EQU	*
	LDB	#1	
L00851	EQU	*
	TSTB
	BEQ	L00852		if conditional expression is false
	LDD	G00187+0,PCR	variable True, declared at minilisp.c:105
	BRA	L00853		end of true expression of conditional
L00852	EQU	*
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
L00853	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_gensym(): defined at minilisp.c:932
_prim_gensym	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-12,S	
* Line minilisp.c:933: init of variable count
	CLRA
	CLRB
	STD	-12,U		variable count
* Line minilisp.c:936: return with value
* Line minilisp.c:936: function call: make_symbol()
	LEAX	-10,U		address of array buf
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:932
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_make_symbol
	LEAS	4,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_if(): defined at minilisp.c:1061
_prim_if	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-18,S	
* Line minilisp.c:1062: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:1062: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BGE	L00855	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1063: function call: printf()
	LEAX	S00272,PCR	"MALFORMED IF\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1063: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00855	EQU	*		else
* Useless label removed
* Line minilisp.c:1064: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:1061
* optim: remove16BitStackOperation
	LEAX	-16,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1064: for init
* Line minilisp.c:1064: init of variable i
	CLRA
	LDB	#$01		1
	STD	-18,U		variable i
	BRA	L00858		jump to for condition
L00857	EQU	*
* Line minilisp.c:1064: for body
* Line minilisp.c:1064: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-16,U		address of array root_ADD_ROOT_
	LDD	-18,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:1064: for increment(s)
	LDD	-18,U	
	ADDD	#1	
	STD	-18,U	
L00858	EQU	*
* Line minilisp.c:1064: for condition
	LDD	-18,U		variable i
	CMPD	#$03	
	BLE	L00857	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:1064: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-8,U		index 4 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1064: assignment: =
	LEAX	-16,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:1064: init of variable cond
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-6,U		variable cond
* Line minilisp.c:1064: init of variable then
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable then
* Line minilisp.c:1064: init of variable els
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable els
* Line minilisp.c:1065: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-6,U		indirection of variable cond
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1066: assignment: =
* Line minilisp.c:1066: function call: eval()
	LDY	-6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1061
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-6,U		indirection of variable cond
* 
	STD	,X	
* Line minilisp.c:1067: if
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	PSHS	B,A	
	LDX	-6,U		indirection of variable cond
	LDD	,X		indirection
	CMPD	,S++	
	BEQ	L00862	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1068: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable then
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1069: return with value
* Line minilisp.c:1069: function call: eval()
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1061
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
	BRA	L00166		return (minilisp.c:1069)
L00862	EQU	*		else
* Useless label removed
* Line minilisp.c:1071: assignment: =
* optim: optimizeIndexedX
	LDX	[8,U]		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable els
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1072: return with value
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	PSHS	B,A	
	LDX	-2,U		indirection of variable els
	LDD	,X		indirection
	CMPD	,S++	
	BEQ	L00864		if true
	CLRB
	BRA	L00865		false
L00864	EQU	*
	LDB	#1	
L00865	EQU	*
	TSTB
	BEQ	L00866		if conditional expression is false
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	BRA	L00867		end of true expression of conditional
L00866	EQU	*
* Line minilisp.c:1072: function call: progn()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1061
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_progn	
	LEAS	6,S	
L00867	EQU	*
* optim: branchToNextLocation
L00166	EQU	*		end of prim_if()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_lambda(): defined at minilisp.c:1005
_prim_lambda	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:1006: return with value
* Line minilisp.c:1006: function call: handle_function()
	LDY	#$05		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1005
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_handle_function
	LEAS	8,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_load(): defined at minilisp.c:1158
_prim_load	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-15,S	
* Line minilisp.c:1159: if
	LDB	G00207+0,PCR	variable doing_load, declared at minilisp.c:429
* optim: loadCmpZeroBeqOrBne
	BEQ	L00869	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1160: return with value
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	LBRA	L00175		return (minilisp.c:1160)
L00869	EQU	*		else
* Useless label removed
* Line minilisp.c:1162: init of variable args
* Line minilisp.c:1162: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1158
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-15,U		variable args
* Line minilisp.c:1163: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-15,U		variable args
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	,X		member type of Obj
	CMPD	#3		optim: optimizeStackOperations1
	BEQ	L00872	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1164: function call: printf()
	LEAX	S00283,PCR	"MALFORMED LOAD\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1164: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00872	EQU	*		else
* Useless label removed
* Line minilisp.c:1167: function call: strncpy()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		argument 3 of strncpy()
	LDX	-15,U		variable args
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LEAX	,X		member name of val
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	-13,U		address of array filebuf
	PSHS	X		argument 1 of strncpy()
	LBSR	_strncpy
	LEAS	6,S	
* Line minilisp.c:1168: function call: strcat()
	LEAY	S00284,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-13,U		address of array filebuf
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_strcat	
	LEAS	4,S	
* Line minilisp.c:1169: if
* Line minilisp.c:1169: function call: open()
	LEAY	-13,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	G00208+0,PCR	variable fd, declared at minilisp.c:430
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_open	
	LEAS	4,S	
	TSTB
	BEQ	L00875	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1170: assignment: =
	CLRA
* optim: stripConsecutiveLoadsToSameReg
	LDB	#$01	
	STB	G00207+0,PCR
	BRA	L00876		jump over else clause
L00875	EQU	*		else
* Line minilisp.c:1172: return with value
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	BRA	L00175		return (minilisp.c:1172)
L00876	EQU	*		end if
* Line minilisp.c:1175: return with value
	LDD	G00187+0,PCR	variable True, declared at minilisp.c:105
* optim: branchToNextLocation
L00175	EQU	*		end of prim_load()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_lt(): defined at minilisp.c:978
_prim_lt	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line minilisp.c:979: init of variable args
* Line minilisp.c:979: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:978
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-6,U		variable args
* Line minilisp.c:980: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:980: function call: length()
	LDD	-6,U		variable args, declared at minilisp.c:979
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L00878	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:981: function call: printf()
	LEAX	S00265,PCR	"MALFORMED <\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:981: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00878	EQU	*		else
* Useless label removed
* Line minilisp.c:982: init of variable x
	LDX	-6,U		variable args
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-4,U		variable x
* Line minilisp.c:983: init of variable y
	LDX	-6,U		variable args
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-2,U		variable y
* Line minilisp.c:984: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BNE	L00880	
* optim: branchToNextLocation
* Useless label removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BEQ	L00881	
* optim: condBranchOverUncondBranch
L00880	EQU	*		then
* Line minilisp.c:985: function call: printf()
	LEAX	S00266,PCR	"< TAKES ONLY NUMBERS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:985: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00881	EQU	*		else
* Useless label removed
* Line minilisp.c:986: return with value
	LDX	-2,U		variable y
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	PSHS	B,A	
	LDX	-4,U		variable x
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	CMPD	,S++	
	BLT	L00884		if true
	CLRB
	BRA	L00885		false
L00884	EQU	*
	LDB	#1	
L00885	EQU	*
	TSTB
	BEQ	L00886		if conditional expression is false
	LDD	G00187+0,PCR	variable True, declared at minilisp.c:105
	BRA	L00887		end of true expression of conditional
L00886	EQU	*
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
L00887	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_macroexpand(): defined at minilisp.c:1043
_prim_macroexpand	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-10,S	
* Line minilisp.c:1044: if
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A	
* Line minilisp.c:1044: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L00889	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1045: function call: printf()
	LEAX	S00271,PCR	"MALFORMED MACROEXPAND\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1045: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00889	EQU	*		else
* Useless label removed
* Line minilisp.c:1046: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:1043
* optim: remove16BitStackOperation
	LEAX	-8,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1046: for init
* Line minilisp.c:1046: init of variable i
	CLRA
	LDB	#$01		1
	STD	-10,U		variable i
	BRA	L00892		jump to for condition
L00891	EQU	*
* Line minilisp.c:1046: for body
* Line minilisp.c:1046: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-8,U		address of array root_ADD_ROOT_
	LDD	-10,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:1046: for increment(s)
	LDD	-10,U	
	ADDD	#1	
	STD	-10,U	
L00892	EQU	*
* Line minilisp.c:1046: for condition
	LDD	-10,U		variable i
	CMPD	#$01	
	BLE	L00891	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:1046: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-4,U		index 2 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1046: assignment: =
	LEAX	-8,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:1046: init of variable body
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable body
* Line minilisp.c:1047: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable body
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1048: return with value
* Line minilisp.c:1048: function call: macroexpand()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1043
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_macroexpand
	LEAS	6,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_minus(): defined at minilisp.c:964
_prim_minus	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line minilisp.c:965: init of variable args
* Line minilisp.c:965: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:964
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-4,U		variable args
* Line minilisp.c:966: for init
* Line minilisp.c:966: init of variable p
* optim: storeLoad
	STD	-6,U		variable p
	BRA	L00896		jump to for condition
L00895	EQU	*
* Line minilisp.c:966: for body
* Line minilisp.c:967: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-6,U		variable p
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	,X		member type of Obj
	CMPD	#1		optim: optimizeStackOperations1
	BEQ	L00900	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:968: function call: printf()
	LEAX	S00264,PCR	"- TAKES ONLY NUMBERS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:968: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00900	EQU	*		else
* Useless label removed
* Useless label removed
* Line minilisp.c:966: for increment(s)
* Line minilisp.c:966: assignment: =
	LDX	-6,U		variable p
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	-6,U	
L00896	EQU	*
* Line minilisp.c:966: for condition
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-6,U		optim: optimize16BitCompares
	BNE	L00895		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:969: if
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	PSHS	B,A	
	LDX	-4,U		variable args
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	CMPD	,S++	
	BNE	L00903	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:970: return with value
* Line minilisp.c:970: function call: make_int()
	LDX	-4,U		variable args
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	COMA
	COMB
	ADDD	#1	
	PSHS	B,A		argument 2 of make_int()
	LDD	4,U		variable root, declared at minilisp.c:964
	PSHS	B,A		argument 1 of make_int()
	LBSR	_make_int
	LEAS	4,S	
	LBRA	L00156		return (minilisp.c:970)
L00903	EQU	*		else
* Useless label removed
* Line minilisp.c:971: init of variable r
	LDX	-4,U		variable args
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	STD	-2,U		variable r
* Line minilisp.c:972: for init
* Line minilisp.c:972: init of variable p
	LDX	-4,U		variable args
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	-6,U		variable p
	BRA	L00906		jump to for condition
L00905	EQU	*
* Line minilisp.c:972: for body
* Line minilisp.c:972: assignment: -=
	LDX	-6,U		variable p
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	PSHS	B,A	
	LDD	-2,U	
	SUBD	,S++	
	STD	-2,U	
* Useless label removed
* Line minilisp.c:972: for increment(s)
* Line minilisp.c:972: assignment: =
	LDX	-6,U		variable p
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	-6,U	
L00906	EQU	*
* Line minilisp.c:972: for condition
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-6,U		optim: optimize16BitCompares
	BNE	L00905		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:974: return with value
* Line minilisp.c:974: function call: make_int()
	LDX	-2,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:964
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_make_int
	LEAS	4,S	
* optim: branchToNextLocation
L00156	EQU	*		end of prim_minus()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_mult(): defined at minilisp.c:952
_prim_mult	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-4,S	
* Line minilisp.c:953: init of variable prod
	CLRA
	LDB	#$01		1
	STD	-2,U		variable prod
* Line minilisp.c:954: for init
* Line minilisp.c:954: init of variable args
* Line minilisp.c:954: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:952
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-4,U		variable args
	LBRA	L00910		jump to for condition
L00909	EQU	*
* Line minilisp.c:954: for body
* Line minilisp.c:955: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-4,U		variable args
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	,X		member type of Obj
	CMPD	#1		optim: optimizeStackOperations1
	BEQ	L00914	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:956: function call: printf()
	LEAX	S00263,PCR	"* TAKES ONLY NUMBERS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:956: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00914	EQU	*		else
* Useless label removed
* Line minilisp.c:957: assignment: *=
	LDX	-4,U		variable args
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
* optim: remove16BitStackOperation
* optim: remove16BitStackOperation
	LDX	-2,U	
	LBSR	MUL16	
	STD	-2,U	
* Useless label removed
* Line minilisp.c:954: for increment(s)
* Line minilisp.c:954: assignment: =
	LDX	-4,U		variable args
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	-4,U	
L00910	EQU	*
* Line minilisp.c:954: for condition
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-4,U		optim: optimize16BitCompares
	LBNE	L00909		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:959: return with value
* Line minilisp.c:959: function call: make_int()
	LDX	-2,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:952
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_make_int
	LEAS	4,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_num_eq(): defined at minilisp.c:1076
_prim_num_eq	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line minilisp.c:1077: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:1077: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L00917	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1078: function call: printf()
	LEAX	S00273,PCR	"MALFORMED =\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1078: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00917	EQU	*		else
* Useless label removed
* Line minilisp.c:1079: init of variable values
* Line minilisp.c:1079: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1076
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-6,U		variable values
* Line minilisp.c:1080: init of variable x
	LDX	-6,U		variable values
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-4,U		variable x
* Line minilisp.c:1081: init of variable y
	LDX	-6,U		variable values
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-2,U		variable y
* Line minilisp.c:1082: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BNE	L00919	
* optim: branchToNextLocation
* Useless label removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BEQ	L00920	
* optim: condBranchOverUncondBranch
L00919	EQU	*		then
* Line minilisp.c:1083: function call: printf()
	LEAX	S00274,PCR	"= ONLY TAKES NUMBERS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1083: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00920	EQU	*		else
* Useless label removed
* Line minilisp.c:1084: return with value
	LDX	-2,U		variable y
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	PSHS	B,A	
	LDX	-4,U		variable x
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	CMPD	,S++	
	BEQ	L00923		if true
	CLRB
	BRA	L00924		false
L00923	EQU	*
	LDB	#1	
L00924	EQU	*
	TSTB
	BEQ	L00925		if conditional expression is false
	LDD	G00187+0,PCR	variable True, declared at minilisp.c:105
	BRA	L00926		end of true expression of conditional
L00925	EQU	*
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
L00926	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_num_gt(): defined at minilisp.c:1100
_prim_num_gt	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line minilisp.c:1101: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:1101: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L00928	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1102: function call: printf()
	LEAX	S00276,PCR	"MALFORMED >\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1102: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00928	EQU	*		else
* Useless label removed
* Line minilisp.c:1103: init of variable values
* Line minilisp.c:1103: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1100
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-6,U		variable values
* Line minilisp.c:1104: init of variable x
	LDX	-6,U		variable values
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-4,U		variable x
* Line minilisp.c:1105: init of variable y
	LDX	-6,U		variable values
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-2,U		variable y
* Line minilisp.c:1106: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BNE	L00930	
* optim: branchToNextLocation
* Useless label removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BEQ	L00931	
* optim: condBranchOverUncondBranch
L00930	EQU	*		then
* Line minilisp.c:1107: function call: printf()
	LEAX	S00277,PCR	"> ONLY TAKES NUMBERS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1107: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00931	EQU	*		else
* Useless label removed
* Line minilisp.c:1108: return with value
	LDX	-2,U		variable y
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	PSHS	B,A	
	LDX	-4,U		variable x
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	CMPD	,S++	
	BGT	L00934		if true
	CLRB
	BRA	L00935		false
L00934	EQU	*
	LDB	#1	
L00935	EQU	*
	TSTB
	BEQ	L00936		if conditional expression is false
	LDD	G00187+0,PCR	variable True, declared at minilisp.c:105
	BRA	L00937		end of true expression of conditional
L00936	EQU	*
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
L00937	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_num_gte(): defined at minilisp.c:1124
_prim_num_gte	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line minilisp.c:1125: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:1125: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L00939	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1126: function call: printf()
	LEAX	S00280,PCR	"MALFORMED >=\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1126: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00939	EQU	*		else
* Useless label removed
* Line minilisp.c:1127: init of variable values
* Line minilisp.c:1127: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1124
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-6,U		variable values
* Line minilisp.c:1128: init of variable x
	LDX	-6,U		variable values
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-4,U		variable x
* Line minilisp.c:1129: init of variable y
	LDX	-6,U		variable values
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-2,U		variable y
* Line minilisp.c:1130: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BNE	L00941	
* optim: branchToNextLocation
* Useless label removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BEQ	L00942	
* optim: condBranchOverUncondBranch
L00941	EQU	*		then
* Line minilisp.c:1131: function call: printf()
	LEAX	S00281,PCR	">= ONLY TAKES NUMBERS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1131: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00942	EQU	*		else
* Useless label removed
* Line minilisp.c:1132: return with value
	LDX	-2,U		variable y
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	PSHS	B,A	
	LDX	-4,U		variable x
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	CMPD	,S++	
	BGE	L00945		if true
	CLRB
	BRA	L00946		false
L00945	EQU	*
	LDB	#1	
L00946	EQU	*
	TSTB
	BEQ	L00947		if conditional expression is false
	LDD	G00187+0,PCR	variable True, declared at minilisp.c:105
	BRA	L00948		end of true expression of conditional
L00947	EQU	*
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
L00948	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_num_lt(): defined at minilisp.c:1088
_prim_num_lt	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line minilisp.c:1089: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:1089: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L00950	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1090: function call: printf()
	LEAX	S00265,PCR	"MALFORMED <\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1090: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00950	EQU	*		else
* Useless label removed
* Line minilisp.c:1091: init of variable values
* Line minilisp.c:1091: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1088
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-6,U		variable values
* Line minilisp.c:1092: init of variable x
	LDX	-6,U		variable values
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-4,U		variable x
* Line minilisp.c:1093: init of variable y
	LDX	-6,U		variable values
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-2,U		variable y
* Line minilisp.c:1094: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BNE	L00952	
* optim: branchToNextLocation
* Useless label removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BEQ	L00953	
* optim: condBranchOverUncondBranch
L00952	EQU	*		then
* Line minilisp.c:1095: function call: printf()
	LEAX	S00275,PCR	"< ONLY TAKES NUMBERS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1095: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00953	EQU	*		else
* Useless label removed
* Line minilisp.c:1096: return with value
	LDX	-2,U		variable y
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	PSHS	B,A	
	LDX	-4,U		variable x
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	CMPD	,S++	
	BLT	L00956		if true
	CLRB
	BRA	L00957		false
L00956	EQU	*
	LDB	#1	
L00957	EQU	*
	TSTB
	BEQ	L00958		if conditional expression is false
	LDD	G00187+0,PCR	variable True, declared at minilisp.c:105
	BRA	L00959		end of true expression of conditional
L00958	EQU	*
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
L00959	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_num_lte(): defined at minilisp.c:1112
_prim_num_lte	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line minilisp.c:1113: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:1113: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L00961	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:1114: function call: printf()
	LEAX	S00278,PCR	"MALFORMED <=\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1114: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00961	EQU	*		else
* Useless label removed
* Line minilisp.c:1115: init of variable values
* Line minilisp.c:1115: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1112
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-6,U		variable values
* Line minilisp.c:1116: init of variable x
	LDX	-6,U		variable values
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-4,U		variable x
* Line minilisp.c:1117: init of variable y
	LDX	-6,U		variable values
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	STD	-2,U		variable y
* Line minilisp.c:1118: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BNE	L00963	
* optim: branchToNextLocation
* Useless label removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	CMPD	#1		optim: optimizeStackOperations1
	BEQ	L00964	
* optim: condBranchOverUncondBranch
L00963	EQU	*		then
* Line minilisp.c:1119: function call: printf()
	LEAX	S00279,PCR	"<= ONLY TAKES NUMBERS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1119: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00964	EQU	*		else
* Useless label removed
* Line minilisp.c:1120: return with value
	LDX	-2,U		variable y
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	PSHS	B,A	
	LDX	-4,U		variable x
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	CMPD	,S++	
	BLE	L00967		if true
	CLRB
	BRA	L00968		false
L00967	EQU	*
	LDB	#1	
L00968	EQU	*
	TSTB
	BEQ	L00969		if conditional expression is false
	LDD	G00187+0,PCR	variable True, declared at minilisp.c:105
	BRA	L00970		end of true expression of conditional
L00969	EQU	*
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
L00970	EQU	*
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_plus(): defined at minilisp.c:940
_prim_plus	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-4,S	
* Line minilisp.c:941: init of variable sum
	CLRA
	CLRB
	STD	-2,U		variable sum
* Line minilisp.c:942: for init
* Line minilisp.c:942: init of variable args
* Line minilisp.c:942: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:940
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	STD	-4,U		variable args
	LBRA	L00972		jump to for condition
L00971	EQU	*
* Line minilisp.c:942: for body
* Line minilisp.c:943: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-4,U		variable args
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	,X		member type of Obj
	CMPD	#1		optim: optimizeStackOperations1
	BEQ	L00976	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:944: function call: printf()
	LEAX	S00262,PCR	"+ TAKES ONLY NUMBERS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:944: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00976	EQU	*		else
* Useless label removed
* Line minilisp.c:945: assignment: +=
	LDX	-4,U		variable args
	LEAX	4,X		member val of Obj
	LDX	,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	ADDD	-2,U		optim: pushDLoadAdd
* 
* 
	STD	-2,U	
* Useless label removed
* Line minilisp.c:942: for increment(s)
* Line minilisp.c:942: assignment: =
	LDX	-4,U		variable args
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	-4,U	
L00972	EQU	*
* Line minilisp.c:942: for condition
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	-4,U		optim: optimize16BitCompares
	LBNE	L00971		optim: optimize16BitCompares
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:947: return with value
* Line minilisp.c:947: function call: make_int()
	LDX	-2,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:940
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_make_int
	LEAS	4,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_println(): defined at minilisp.c:1052
_prim_println	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-10,S	
* Line minilisp.c:1053: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:1052
* optim: remove16BitStackOperation
	LEAX	-8,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1053: for init
* Line minilisp.c:1053: init of variable i
	CLRA
	LDB	#$01		1
	STD	-10,U		variable i
	BRA	L00979		jump to for condition
L00978	EQU	*
* Line minilisp.c:1053: for body
* Line minilisp.c:1053: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-8,U		address of array root_ADD_ROOT_
	LDD	-10,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:1053: for increment(s)
	LDD	-10,U	
	ADDD	#1	
	STD	-10,U	
L00979	EQU	*
* Line minilisp.c:1053: for condition
	LDD	-10,U		variable i
	CMPD	#$01	
	BLE	L00978	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:1053: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-4,U		index 2 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1053: assignment: =
	LEAX	-8,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:1053: init of variable tmp
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable tmp
* Line minilisp.c:1054: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable tmp
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:1055: function call: print()
* Line minilisp.c:1055: function call: eval()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:1052
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
	PSHS	B,A		argument 1 of print()
	LBSR	_print	
	LEAS	2,S	
* Line minilisp.c:1056: function call: printf()
	LEAX	S00228,PCR	"\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:1057: return with value
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_quote(): defined at minilisp.c:863
_prim_quote	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:864: if
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A	
* Line minilisp.c:864: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L00983	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:865: function call: printf()
	LEAX	S00254,PCR	"MALFORMED QUOTE\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:865: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00983	EQU	*		else
* Useless label removed
* Line minilisp.c:866: return with value
* optim: optimizeIndexedX
	LDX	[8,U]		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_setcar(): defined at minilisp.c:909
_prim_setcar	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-10,S	
* Line minilisp.c:910: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:909
* optim: remove16BitStackOperation
	LEAX	-8,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:910: for init
* Line minilisp.c:910: init of variable i
	CLRA
	LDB	#$01		1
	STD	-10,U		variable i
	BRA	L00986		jump to for condition
L00985	EQU	*
* Line minilisp.c:910: for body
* Line minilisp.c:910: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-8,U		address of array root_ADD_ROOT_
	LDD	-10,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:910: for increment(s)
	LDD	-10,U	
	ADDD	#1	
	STD	-10,U	
L00986	EQU	*
* Line minilisp.c:910: for condition
	LDD	-10,U		variable i
	CMPD	#$01	
	BLE	L00985	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:910: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-4,U		index 2 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:910: assignment: =
	LEAX	-8,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:910: init of variable args
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable args
* Line minilisp.c:911: assignment: =
* Line minilisp.c:911: function call: eval_list()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:909
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable args
* 
	STD	,X	
* Line minilisp.c:912: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:912: function call: length()
	LDX	-2,U		indirection of variable args
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BNE	L00989	
* optim: branchToNextLocation
* Useless label removed
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BEQ	L00990	
* optim: condBranchOverUncondBranch
L00989	EQU	*		then
* Line minilisp.c:913: function call: printf()
	LEAX	S00260,PCR	"MALFORMED SETCAR\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:913: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00990	EQU	*		else
* Useless label removed
* Line minilisp.c:914: assignment: =
* optim: optimizeIndexedX
	LDX	[-2,U]		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,S++	
	STD	,X	
* Line minilisp.c:915: return with value
* optim: optimizeIndexedX
	LDX	[-2,U]		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_setq(): defined at minilisp.c:895
_prim_setq	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-14,S	
* Line minilisp.c:896: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:896: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BNE	L00993	
* optim: branchToNextLocation
* Useless label removed
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BEQ	L00994	
* optim: condBranchOverUncondBranch
L00993	EQU	*		then
* Line minilisp.c:897: function call: printf()
	LEAX	S00258,PCR	"MALFORMED SETQ\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:897: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L00994	EQU	*		else
* Useless label removed
* Line minilisp.c:898: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:895
* optim: remove16BitStackOperation
	LEAX	-12,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:898: for init
* Line minilisp.c:898: init of variable i
	CLRA
	LDB	#$01		1
	STD	-14,U		variable i
	BRA	L00998		jump to for condition
L00997	EQU	*
* Line minilisp.c:898: for body
* Line minilisp.c:898: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-12,U		address of array root_ADD_ROOT_
	LDD	-14,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:898: for increment(s)
	LDD	-14,U	
	ADDD	#1	
	STD	-14,U	
L00998	EQU	*
* Line minilisp.c:898: for condition
	LDD	-14,U		variable i
	CMPD	#$02	
	BLE	L00997	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:898: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-6,U		index 3 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:898: assignment: =
	LEAX	-12,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:898: init of variable bind
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable bind
* Line minilisp.c:898: init of variable value
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable value
* Line minilisp.c:899: assignment: =
* Line minilisp.c:899: function call: find()
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDX	,X		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	6,U		variable env, declared at minilisp.c:895
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_find	
	LEAS	4,S	
* optim: pushDLoadXLoadD
	LDX	-4,U		indirection of variable bind
* 
	STD	,X	
* Line minilisp.c:900: if
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
* optim: loadCmpZeroBeqOrBne
	BNE	L01002	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:901: function call: printf()
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LEAX	,X		member name of val
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00259,PCR	"UNBOUND VARIABLE %s\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
* Line minilisp.c:901: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L01002	EQU	*		else
* Useless label removed
* Line minilisp.c:902: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable value
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:903: assignment: =
* Line minilisp.c:903: function call: eval()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:895
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable value
* 
	STD	,X	
* Line minilisp.c:904: assignment: =
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LEAX	2,X		member cdr of cell
	LDD	,S++	
	STD	,X	
* Line minilisp.c:905: return with value
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION prim_while(): defined at minilisp.c:919
_prim_while	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-14,S	
* Line minilisp.c:920: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* Line minilisp.c:920: function call: length()
	LDX	8,U		indirection of variable list
	LDD	,X		indirection
	PSHS	B,A		argument 1 of length()
	LBSR	_length	
	LEAS	2,S	
	CMPD	,S++	
	BGE	L01005	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:921: function call: printf()
	LEAX	S00261,PCR	"MALFORMED WHILE\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:921: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L01005	EQU	*		else
* Useless label removed
* Line minilisp.c:922: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:919
* optim: remove16BitStackOperation
	LEAX	-12,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:922: for init
* Line minilisp.c:922: init of variable i
	CLRA
	LDB	#$01		1
	STD	-14,U		variable i
	BRA	L01008		jump to for condition
L01007	EQU	*
* Line minilisp.c:922: for body
* Line minilisp.c:922: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-12,U		address of array root_ADD_ROOT_
	LDD	-14,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:922: for increment(s)
	LDD	-14,U	
	ADDD	#1	
	STD	-14,U	
L01008	EQU	*
* Line minilisp.c:922: for condition
	LDD	-14,U		variable i
	CMPD	#$02	
	BLE	L01007	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:922: assignment: =
* LDD #$FFFF optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-6,U		index 3 in array root_ADD_ROOT_[]
	LDD	#65535		optim: optimizeStackOperations1
	STD	,X	
* Line minilisp.c:922: assignment: =
	LEAX	-12,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:922: init of variable cond
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable cond
* Line minilisp.c:922: init of variable exprs
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable exprs
* Line minilisp.c:923: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable cond
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:924: while
L01012	EQU	*		while condition at minilisp.c:924
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	PSHS	B,A	
* Line minilisp.c:924: function call: eval()
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:919
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
	CMPD	,S++	
	BEQ	L01013	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:925: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable exprs
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:926: function call: eval_list()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:919
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval_list
	LEAS	6,S	
	BRA	L01012		go to while condition
L01013	EQU	*		after end of while starting at minilisp.c:924
* Line minilisp.c:928: return with value
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION print(): defined at minilisp.c:668
_print	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:669: switch
* optim: optimizeIndexedX
	LDD	[4,U]		optim: optimizeIndexedX
	CMPD	#$02		case 2
	BEQ	L01015	
	CMPD	#$01		case 1
	LBEQ	L01016	
	CMPD	#$03		case 3
	LBEQ	L01017	
	CMPD	#$04		case 4
	LBEQ	L01018	
	CMPD	#$05		case 5
	LBEQ	L01019	
	CMPD	#$06		case 6
	LBEQ	L01020	
	CMPD	#$08		case 8
	LBEQ	L01021	
	CMPD	#$09		case 9
	LBEQ	L01022	
	CMPD	#$0A		case 10
	LBEQ	L01023	
	LBRA	L01024		switch default
L01015	EQU	*		case 2
* Line minilisp.c:671: function call: printf()
	LEAX	S00235,PCR	"("
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
L01025	EQU	*
* Line minilisp.c:672: for body
* Line minilisp.c:673: function call: print()
	LDX	4,U		variable obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
	PSHS	B,A		argument 1 of print()
	LBSR	_print	
	LEAS	2,S	
* Line minilisp.c:674: if
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	PSHS	B,A	
	LDX	4,U		variable obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	CMPD	,S++	
	BNE	L01030	
* optim: condBranchOverUncondBranch
* Useless label removed
	BRA	L01028		break
L01030	EQU	*		else
* Useless label removed
* Line minilisp.c:676: if
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable obj
	LEAX	4,X		member val of Obj
	LDX	2,X		optim: removeTfrDX
* optim: removeTfrDX
	LDD	,X		member type of Obj
	CMPD	#2		optim: optimizeStackOperations1
	BEQ	L01033	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:677: function call: printf()
	LEAX	S00236,PCR	" . "
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:678: function call: print()
	LDX	4,U		variable obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	PSHS	B,A		argument 1 of print()
	LBSR	_print	
	LEAS	2,S	
	BRA	L01028		break
L01033	EQU	*		else
* Useless label removed
* Line minilisp.c:681: function call: printf()
	LEAX	S00237,PCR	" "
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:682: assignment: =
	LDX	4,U		variable obj
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	4,U	
* Useless label removed
	LBRA	L01025	
L01028	EQU	*		end for
* Line minilisp.c:684: function call: printf()
	LEAX	S00238,PCR	")"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
	LBRA	L00132		return (minilisp.c:685)
L01016	EQU	*		case 1
* Line minilisp.c:691: function call: printf()
	LDX	4,U		variable obj
	LEAX	4,X		member val of Obj
	LDD	,X		member value of val
	PSHS	B,A		argument 2 of printf()
	LEAX	S00239,PCR	"%d"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
	LBRA	L00132		return (minilisp.c:691)
L01017	EQU	*		case 3
* Line minilisp.c:692: function call: printf()
	LDX	4,U		variable obj
	LEAX	4,X		member val of Obj
	LEAX	,X		member name of val
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LEAX	S00240,PCR	"%s"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
	LBRA	L00132		return (minilisp.c:692)
L01018	EQU	*		case 4
* Line minilisp.c:693: function call: printf()
	LEAX	S00241,PCR	"<PRIMITIVE>"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
	LBRA	L00132		return (minilisp.c:693)
L01019	EQU	*		case 5
* Line minilisp.c:694: function call: printf()
	LEAX	S00242,PCR	"<FUNCTION>"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
	LBRA	L00132		return (minilisp.c:694)
L01020	EQU	*		case 6
* Line minilisp.c:695: function call: printf()
	LEAX	S00243,PCR	"<MACRO>"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
	LBRA	L00132		return (minilisp.c:695)
L01021	EQU	*		case 8
* Line minilisp.c:696: function call: printf()
	LEAX	S00244,PCR	"<MOVED>"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
	BRA	L00132		return (minilisp.c:696)
L01022	EQU	*		case 9
* Line minilisp.c:697: function call: printf()
	LEAX	S00245,PCR	"T"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
	BRA	L00132		return (minilisp.c:697)
L01023	EQU	*		case 10
* Line minilisp.c:698: function call: printf()
	LEAX	S00246,PCR	"()"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
	BRA	L00132		return (minilisp.c:698)
L01024	EQU	*		default
* Line minilisp.c:701: function call: printf()
* optim: optimizeIndexedX
	LDD	[4,U]		optim: optimizeIndexedX
	PSHS	B,A		argument 2 of printf()
	LEAX	S00247,PCR	"BUG: PRINT: UNKNOWN TAG TYPE: %d\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
* Line minilisp.c:701: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
* Useless label removed
L00132	EQU	*		end of print()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION progn(): defined at minilisp.c:750
_progn	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-14,S	
* Line minilisp.c:751: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:750
* optim: remove16BitStackOperation
	LEAX	-12,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:751: for init
* Line minilisp.c:751: init of variable i
	CLRA
	LDB	#$01		1
	STD	-14,U		variable i
	BRA	L01036		jump to for condition
L01035	EQU	*
* Line minilisp.c:751: for body
* Line minilisp.c:751: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-12,U		address of array root_ADD_ROOT_
	LDD	-14,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:751: for increment(s)
	LDD	-14,U	
	ADDD	#1	
	STD	-14,U	
L01036	EQU	*
* Line minilisp.c:751: for condition
	LDD	-14,U		variable i
	CMPD	#$02	
	BLE	L01035	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:751: assignment: =
* LDD #$FFFF optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-6,U		index 3 in array root_ADD_ROOT_[]
	LDD	#65535		optim: optimizeStackOperations1
	STD	,X	
* Line minilisp.c:751: assignment: =
	LEAX	-12,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:751: init of variable lp
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable lp
* Line minilisp.c:751: init of variable r
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable r
* Line minilisp.c:752: for init
* Line minilisp.c:752: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable lp
* optim: remove16BitStackOperation
	STD	,X	
	BRA	L01040		jump to for condition
L01039	EQU	*
* Line minilisp.c:752: for body
* Line minilisp.c:753: assignment: =
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable r
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:754: assignment: =
* Line minilisp.c:754: function call: eval()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:750
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_eval	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable r
* 
	STD	,X	
* Useless label removed
* Line minilisp.c:752: for increment(s)
* Line minilisp.c:752: assignment: =
* optim: optimizeIndexedX
	LDX	[-4,U]		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable lp
* optim: remove16BitStackOperation
	STD	,X	
L01040	EQU	*
* Line minilisp.c:752: for condition
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	PSHS	B,A	
	LDX	-4,U		indirection of variable lp
	LDD	,X		indirection
	CMPD	,S++	
	BNE	L01039	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:756: return with value
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION push_env(): defined at minilisp.c:734
_push_env	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-18,S	
* Line minilisp.c:735: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:734
* optim: remove16BitStackOperation
	LEAX	-16,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:735: for init
* Line minilisp.c:735: init of variable i
	CLRA
	LDB	#$01		1
	STD	-18,U		variable i
	BRA	L01044		jump to for condition
L01043	EQU	*
* Line minilisp.c:735: for body
* Line minilisp.c:735: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-16,U		address of array root_ADD_ROOT_
	LDD	-18,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:735: for increment(s)
	LDD	-18,U	
	ADDD	#1	
	STD	-18,U	
L01044	EQU	*
* Line minilisp.c:735: for condition
	LDD	-18,U		variable i
	CMPD	#$03	
	BLE	L01043	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:735: assignment: =
* LDD #$FFFF optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-8,U		index 4 in array root_ADD_ROOT_[]
	LDD	#65535		optim: optimizeStackOperations1
	STD	,X	
* Line minilisp.c:735: assignment: =
	LEAX	-16,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:735: init of variable map
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-6,U		variable map
* Line minilisp.c:735: init of variable sym
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable sym
* Line minilisp.c:735: init of variable val
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable val
* Line minilisp.c:736: assignment: =
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: remove16BitStackOperation
	LDX	-6,U		indirection of variable map
* optim: remove16BitStackOperation
	STD	,X	
	LBRA	L01048		jump to for condition
L01047	EQU	*
* Line minilisp.c:737: for body
* Line minilisp.c:738: if
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[10,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	BEQ	L01052	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:739: function call: printf()
	LEAX	S00248,PCR	"CANNOT APPLY FUNCTION: NUMBER OF ARGUMENTS DO NOT MATCH\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:739: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L01052	EQU	*		else
* Useless label removed
* Line minilisp.c:740: assignment: =
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable sym
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:741: assignment: =
* optim: optimizeIndexedX
	LDD	[10,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LDD	,X		member car of cell
* optim: remove16BitStackOperation
	LDX	-2,U		indirection of variable val
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:742: assignment: =
* Line minilisp.c:742: function call: acons()
	LDY	-6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-4,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:734
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_acons	
	LEAS	8,S	
* optim: pushDLoadXLoadD
	LDX	-6,U		indirection of variable map
* 
	STD	,X	
* Useless label removed
* Line minilisp.c:737: for increment(s)
* Line minilisp.c:737: assignment: =
* optim: optimizeIndexedX
	LDX	[8,U]		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	8,U		indirection of variable vars
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:737: assignment: =
* optim: optimizeIndexedX
	LDX	[10,U]		optim: removeTfrDX
* optim: removeTfrDX
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
* optim: remove16BitStackOperation
	LDX	10,U		indirection of variable vals
* optim: remove16BitStackOperation
	STD	,X	
L01048	EQU	*
* Line minilisp.c:737: for condition
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[8,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LDD	,X		member type of Obj
	CMPD	,S++	
	LBEQ	L01047	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:744: if
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	PSHS	B,A	
	LDX	8,U		indirection of variable vars
	LDD	,X		indirection
	CMPD	,S++	
	BEQ	L01055	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:745: assignment: =
* Line minilisp.c:745: function call: acons()
	LDY	-6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDY	10,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	8,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:734
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_acons	
	LEAS	8,S	
* optim: pushDLoadXLoadD
	LDX	-6,U		indirection of variable map
* 
	STD	,X	
L01055	EQU	*		else
* Useless label removed
* Line minilisp.c:746: return with value
* Line minilisp.c:746: function call: make_env()
	LDY	6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:734
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_make_env
	LEAS	6,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION read(): defined at /usr/local/share/cmoc/disk.h:252
_read	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line /usr/local/share/cmoc/disk.h:256: if
	LDD	4,U		variable fd, declared at /usr/local/share/cmoc/disk.h:252
* optim: loadCmpZeroBeqOrBne
	BNE	L01058	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:257: return with value
	CLRA
	CLRB
	LBRA	L00082		return (/usr/local/share/cmoc/disk.h:257)
L01058	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:258: if
	LDD	6,U		variable buf, declared at /usr/local/share/cmoc/disk.h:252
* optim: loadCmpZeroBeqOrBne
	BNE	L01061	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:259: return with value
	CLRA
	CLRB
	LBRA	L00082		return (/usr/local/share/cmoc/disk.h:259)
L01061	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:260: if
	LDD	8,U		variable numBytesRequested, declared at /usr/local/share/cmoc/disk.h:252
* optim: loadCmpZeroBeqOrBne
	BNE	L01064	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:261: return with value
	CLRA
	CLRB
	LBRA	L00082		return (/usr/local/share/cmoc/disk.h:261)
L01064	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:263: init of variable bufStart
	LDD	6,U		variable buf, declared at /usr/local/share/cmoc/disk.h:252
	STD	-2,U		variable bufStart
L01066	EQU	*
* Line /usr/local/share/cmoc/disk.h:264: for body
* Line /usr/local/share/cmoc/disk.h:267: init of variable availBytes
* Line /usr/local/share/cmoc/disk.h:267: function call: getCurrentlyAvailableBytes()
	LEAX	-6,U		variable numAvailBytes, declared at /usr/local/share/cmoc/disk.h:266
* optim: optimizePshsOps
	LDD	4,U		variable fd, declared at /usr/local/share/cmoc/disk.h:252
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_getCurrentlyAvailableBytes
	LEAS	4,S	
	STD	-4,U		variable availBytes
* Line /usr/local/share/cmoc/disk.h:270: if
	LDD	-6,U		variable numAvailBytes
	CMPD	8,U		variable numBytesRequested
	BLO	L01071	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:272: function call: memcpy()
	LDY	8,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-4,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	6,U		variable buf, declared at /usr/local/share/cmoc/disk.h:252
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_memcpy	
	LEAS	6,S	
* Line /usr/local/share/cmoc/disk.h:273: assignment: +=
* optim: optimize16BitStackOps2
* optim: optimize16BitStackOps2
	LDD	6,U	
	ADDD	8,U		optim: optimize16BitStackOps2
	STD	6,U	
* Line /usr/local/share/cmoc/disk.h:274: function call: advanceOffset()
	LDX	8,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable fd, declared at /usr/local/share/cmoc/disk.h:252
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_advanceOffset
	LEAS	4,S	
* Line /usr/local/share/cmoc/disk.h:276: return with value
* optim: optimize16BitStackOps1
* optim: optimize16BitStackOps1
	LDD	6,U		variable buf, declared at /usr/local/share/cmoc/disk.h:252
	SUBD	-2,U		optim: optimize16BitStackOps1
	LBRA	L00082		return (/usr/local/share/cmoc/disk.h:276)
L01071	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:281: if
	LDD	-6,U		variable numAvailBytes
	ADDD	#0	
	BLS	L01074	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:284: function call: memcpy()
	LDY	-6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-4,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	6,U		variable buf, declared at /usr/local/share/cmoc/disk.h:252
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_memcpy	
	LEAS	6,S	
* Line /usr/local/share/cmoc/disk.h:285: assignment: +=
* optim: optimize16BitStackOps2
* optim: optimize16BitStackOps2
	LDD	6,U	
	ADDD	-6,U		optim: optimize16BitStackOps2
	STD	6,U	
* Line /usr/local/share/cmoc/disk.h:286: assignment: -=
	LDD	8,U		variable numBytesRequested
	SUBD	-6,U		variable numAvailBytes
	STD	8,U		variable numBytesRequested
* Line /usr/local/share/cmoc/disk.h:287: function call: advanceOffset()
	LDX	-6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable fd, declared at /usr/local/share/cmoc/disk.h:252
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_advanceOffset
	LEAS	4,S	
L01074	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:290: if
* Line /usr/local/share/cmoc/disk.h:290: function call: getNextSector()
	LDD	4,U		variable fd, declared at /usr/local/share/cmoc/disk.h:252
	PSHS	B,A		argument 1 of getNextSector()
	LBSR	_getNextSector
	LEAS	2,S	
	TSTB
	BNE	L01077	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:293: return with value
* optim: optimize16BitStackOps1
* optim: optimize16BitStackOps1
	LDD	6,U		variable buf, declared at /usr/local/share/cmoc/disk.h:252
	SUBD	-2,U		optim: optimize16BitStackOps1
	BRA	L00082		return (/usr/local/share/cmoc/disk.h:293)
L01077	EQU	*		else
* Useless label removed
* Useless label removed
	LBRA	L01066	
* Useless label removed
L00082	EQU	*		end of read()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION readDiskSector(): defined at /usr/local/share/cmoc/disk.h:108
_readDiskSector	EQU	*
	PSHS	U	
	LEAU	,S	
* Line /usr/local/share/cmoc/disk.h:110: return with value
* Line /usr/local/share/cmoc/disk.h:110: function call: dskcon()
	LDB	11,U		variable sector, declared at /usr/local/share/cmoc/disk.h:108
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 5 of dskcon()
	LDB	9,U		variable track, declared at /usr/local/share/cmoc/disk.h:108
* optim: stripExtraClrA_B
	PSHS	B,A		argument 4 of dskcon()
	LDB	7,U		variable drive, declared at /usr/local/share/cmoc/disk.h:108
* optim: stripExtraClrA_B
	PSHS	B,A		argument 3 of dskcon()
	LDX	4,U		optim: transformPshsDPshsD
	PSHS	X		optim: transformPshsDPshsD
* optim: stripExtraClrA_B
	LDB	#$02		decimal 2 signed
	PSHS	B,A		argument 1 of dskcon()
	LBSR	_dskcon	
	LEAS	10,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION read_expr(): defined at minilisp.c:638
_read_expr	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-1,S	
L01079	EQU	*
* Line minilisp.c:639: for body
* Line minilisp.c:640: init of variable c
* Line minilisp.c:640: function call: getchar()
	LBSR	_getchar
	STB	-1,U		variable c
* Line minilisp.c:641: if
* optim: storeLoad
	CMPB	#$20	
	BEQ	L01083	
* optim: branchToNextLocation
* Useless label removed
	LDB	-1,U		variable c
	CMPB	#$0A	
	BEQ	L01083	
* optim: branchToNextLocation
* Useless label removed
	LDB	-1,U		variable c
	CMPB	#$0D	
	BEQ	L01083	
* optim: branchToNextLocation
* Useless label removed
	LDB	-1,U		variable c
	CMPB	#$09	
	BNE	L01084	
* optim: condBranchOverUncondBranch
L01083	EQU	*		then
	LBRA	L01081		continue
L01084	EQU	*		else
* Useless label removed
* Line minilisp.c:643: if
	LDB	-1,U		variable c, declared at minilisp.c:640
* optim: loadCmpZeroBeqOrBne
	BNE	L01090	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:644: return with value
	CLRA
	CLRB
	LBRA	L00131		return (minilisp.c:644)
L01090	EQU	*		else
* Useless label removed
* Line minilisp.c:645: if
	LDB	-1,U		variable c
	CMPB	#$3B	
	BNE	L01093	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:646: function call: skip_line()
	LBSR	_skip_line
	LBRA	L01081		continue
L01093	EQU	*		else
* Useless label removed
* Line minilisp.c:649: if
	LDB	-1,U		variable c
	CMPB	#$28	
	BNE	L01096	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:650: return with value
* Line minilisp.c:650: function call: read_list()
	LDD	4,U		variable root, declared at minilisp.c:638
	PSHS	B,A		argument 1 of read_list()
	LBSR	_read_list
	LEAS	2,S	
	LBRA	L00131		return (minilisp.c:650)
L01096	EQU	*		else
* Useless label removed
* Line minilisp.c:651: if
	LDB	-1,U		variable c
	CMPB	#$29	
	BNE	L01099	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:652: return with value
	LDD	G00190+0,PCR	variable Cparen, declared at minilisp.c:108
	LBRA	L00131		return (minilisp.c:652)
L01099	EQU	*		else
* Useless label removed
* Line minilisp.c:653: if
	LDB	-1,U		variable c
	CMPB	#$2E	
	BNE	L01102	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:654: return with value
	LDD	G00189+0,PCR	variable Dot, declared at minilisp.c:107
	LBRA	L00131		return (minilisp.c:654)
L01102	EQU	*		else
* Useless label removed
* Line minilisp.c:655: if
	LDB	-1,U		variable c
	CMPB	#$27	
	BNE	L01105	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:656: return with value
* Line minilisp.c:656: function call: read_quote()
	LDD	4,U		variable root, declared at minilisp.c:638
	PSHS	B,A		argument 1 of read_quote()
	LBSR	_read_quote
	LEAS	2,S	
	LBRA	L00131		return (minilisp.c:656)
L01105	EQU	*		else
* Useless label removed
* Line minilisp.c:657: if
* Line minilisp.c:657: function call: isdigit()
	LDB	-1,U		variable c, declared at minilisp.c:640
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of isdigit()
	LBSR	_isdigit
	LEAS	2,S	
	TSTB
	BEQ	L01108	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:658: return with value
* Line minilisp.c:658: function call: make_int()
* Line minilisp.c:658: function call: read_number()
	LDB	-1,U	
	SEX
	ADDD	#$FFD0		65488
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of read_number()
	LBSR	_read_number
	LEAS	2,S	
	PSHS	B,A		argument 2 of make_int()
	LDD	4,U		variable root, declared at minilisp.c:638
	PSHS	B,A		argument 1 of make_int()
	LBSR	_make_int
	LEAS	4,S	
	LBRA	L00131		return (minilisp.c:658)
L01108	EQU	*		else
* Useless label removed
* Line minilisp.c:659: if
	LDB	-1,U		variable c
	CMPB	#$2D	
	BNE	L01111	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:659: function call: isdigit()
* Line minilisp.c:659: function call: peek()
	LBSR	_peek	
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of isdigit()
	LBSR	_isdigit
	LEAS	2,S	
	TSTB
	BEQ	L01111	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:660: return with value
* Line minilisp.c:660: function call: make_int()
* Line minilisp.c:660: function call: read_number()
	CLRA
	CLRB
	PSHS	B,A		argument 1 of read_number()
	LBSR	_read_number
	LEAS	2,S	
	COMA
	COMB
	ADDD	#1	
	PSHS	B,A		argument 2 of make_int()
	LDD	4,U		variable root, declared at minilisp.c:638
	PSHS	B,A		argument 1 of make_int()
	LBSR	_make_int
	LEAS	4,S	
	LBRA	L00131		return (minilisp.c:660)
L01111	EQU	*		else
* Useless label removed
* Line minilisp.c:661: if
* Line minilisp.c:661: function call: isalpha()
	LDB	-1,U		variable c, declared at minilisp.c:640
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of isalpha()
	LBSR	_isalpha
	LEAS	2,S	
	TSTB
	BNE	L01114	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:661: function call: strchr()
	LDB	-1,U		variable c, declared at minilisp.c:640
	SEX			promoting byte argument to word
	PSHS	B,A		argument 2 of strchr()
	LEAX	G00202+0,PCR	address of array symbol_chars
	PSHS	X		argument 1 of strchr()
	LBSR	_strchr	
	LEAS	4,S	
	ADDD	#0	
	BEQ	L01115	
* optim: condBranchOverUncondBranch
L01114	EQU	*		then
* Line minilisp.c:662: return with value
* Line minilisp.c:662: function call: read_symbol()
	LDB	-1,U		variable c, declared at minilisp.c:640
	SEX			promoting byte argument to word
	PSHS	B,A		argument 2 of read_symbol()
	LDD	4,U		variable root, declared at minilisp.c:638
	PSHS	B,A		argument 1 of read_symbol()
	LBSR	_read_symbol
	LEAS	4,S	
	BRA	L00131		return (minilisp.c:662)
L01115	EQU	*		else
* Useless label removed
* Line minilisp.c:663: function call: printf()
	LDB	-1,U		variable c, declared at minilisp.c:640
	SEX			promoting byte argument to word
	PSHS	B,A		argument 2 of printf()
	LEAX	S00234,PCR	"DON\'T KNOW HOW TO HANDLE %c"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
* Line minilisp.c:663: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L01081	EQU	*
	LBRA	L01079	
* Useless label removed
L00131	EQU	*		end of read_expr()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION read_list(): defined at minilisp.c:576
_read_list	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-18,S	
* Line minilisp.c:577: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:576
* optim: remove16BitStackOperation
	LEAX	-16,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:577: for init
* Line minilisp.c:577: init of variable i
	CLRA
	LDB	#$01		1
	STD	-18,U		variable i
	BRA	L01119		jump to for condition
L01118	EQU	*
* Line minilisp.c:577: for body
* Line minilisp.c:577: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-16,U		address of array root_ADD_ROOT_
	LDD	-18,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:577: for increment(s)
	LDD	-18,U	
	ADDD	#1	
	STD	-18,U	
L01119	EQU	*
* Line minilisp.c:577: for condition
	LDD	-18,U		variable i
	CMPD	#$03	
	BLE	L01118	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:577: assignment: =
* LDD #$FFFF optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-8,U		index 4 in array root_ADD_ROOT_[]
	LDD	#65535		optim: optimizeStackOperations1
	STD	,X	
* Line minilisp.c:577: assignment: =
	LEAX	-16,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:577: init of variable obj
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-6,U		variable obj
* Line minilisp.c:577: init of variable head
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable head
* Line minilisp.c:577: init of variable last
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable last
* Line minilisp.c:578: assignment: =
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: remove16BitStackOperation
	LDX	-4,U		indirection of variable head
* optim: remove16BitStackOperation
	STD	,X	
L01122	EQU	*
* Line minilisp.c:579: for body
* Line minilisp.c:580: assignment: =
* Line minilisp.c:580: function call: read_expr()
	LDD	4,U		variable root, declared at minilisp.c:576
	PSHS	B,A		argument 1 of read_expr()
	LBSR	_read_expr
	LEAS	2,S	
* optim: pushDLoadXLoadD
	LDX	-6,U		indirection of variable obj
* 
	STD	,X	
* Line minilisp.c:581: if
* optim: optimizeIndexedX
	LDD	[-6,U]		optim: optimizeIndexedX
* optim: loadCmpZeroBeqOrBne
	BNE	L01127	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:582: function call: printf()
	LEAX	S00230,PCR	"UNCLOSED PARENTHESIS\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:582: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L01127	EQU	*		else
* Useless label removed
* Line minilisp.c:583: if
	LDD	G00190+0,PCR	variable Cparen, declared at minilisp.c:108
	PSHS	B,A	
	LDX	-6,U		indirection of variable obj
	LDD	,X		indirection
	CMPD	,S++	
	BNE	L01130	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:584: return with value
* Line minilisp.c:584: function call: reverse()
	LDX	-4,U		indirection of variable head
	LDD	,X		indirection
	PSHS	B,A		argument 1 of reverse()
	LBSR	_reverse
	LEAS	2,S	
	LBRA	L00126		return (minilisp.c:584)
L01130	EQU	*		else
* Useless label removed
* Line minilisp.c:585: if
	LDD	G00189+0,PCR	variable Dot, declared at minilisp.c:107
	PSHS	B,A	
	LDX	-6,U		indirection of variable obj
	LDD	,X		indirection
	CMPD	,S++	
	LBNE	L01133	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:586: assignment: =
* Line minilisp.c:586: function call: read_expr()
	LDD	4,U		variable root, declared at minilisp.c:576
	PSHS	B,A		argument 1 of read_expr()
	LBSR	_read_expr
	LEAS	2,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable last
* 
	STD	,X	
* Line minilisp.c:587: if
	LDD	G00190+0,PCR	variable Cparen, declared at minilisp.c:108
	PSHS	B,A	
* Line minilisp.c:587: function call: read_expr()
	LDD	4,U		variable root, declared at minilisp.c:576
	PSHS	B,A		argument 1 of read_expr()
	LBSR	_read_expr
	LEAS	2,S	
	CMPD	,S++	
	BEQ	L01136	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:588: function call: printf()
	LEAX	S00231,PCR	"CLOSED PARENTHESIS EXPECTED AFTER DOT\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:588: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L01136	EQU	*		else
* Useless label removed
* Line minilisp.c:589: init of variable ret
* Line minilisp.c:589: function call: reverse()
	LDX	-4,U		indirection of variable head
	LDD	,X		indirection
	PSHS	B,A		argument 1 of reverse()
	LBSR	_reverse
	LEAS	2,S	
	STD	-18,U		variable ret
* Line minilisp.c:590: assignment: =
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
	PSHS	B,A	
* optim: optimizeIndexedX
	LDD	[-4,U]		optim: optimizeIndexedX
	TFR	D,X		X points to a struct Obj
	LEAX	4,X		member val of Obj
	LEAX	2,X		member cdr of cell
	LDD	,S++	
	STD	,X	
* Line minilisp.c:591: return with value
	LDD	-18,U		variable ret, declared at minilisp.c:589
	BRA	L00126		return (minilisp.c:591)
L01133	EQU	*		else
* Useless label removed
* Line minilisp.c:593: assignment: =
* Line minilisp.c:593: function call: cons()
	LDY	-4,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-6,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:576
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_cons	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-4,U		indirection of variable head
* 
	STD	,X	
* Useless label removed
	LBRA	L01122	
* Useless label removed
L00126	EQU	*		end of read_list()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION read_number(): defined at minilisp.c:619
_read_number	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:620: while
L01139	EQU	*		while condition at minilisp.c:620
* Line minilisp.c:620: function call: isdigit()
* Line minilisp.c:620: function call: peek()
	LBSR	_peek	
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of isdigit()
	LBSR	_isdigit
	LEAS	2,S	
	TSTB
	BEQ	L01140	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:621: assignment: =
	LDB	#$30		optim: lddToLDB
	SEX			promotion of binary operand
	PSHS	B,A	
* Line minilisp.c:621: function call: getchar()
	LBSR	_getchar
	SEX			promotion of binary operand
	LEAS	1,S	
	SUBB	,S+	
	SEX			promotion of binary operand
	PSHS	B,A	
	LDX	4,U		left
	CLRA
	LDB	#$0A		right
	LBSR	MUL16	
	ADDD	,S++	
	STD	4,U	
	BRA	L01139		go to while condition
L01140	EQU	*		after end of while starting at minilisp.c:620
* Line minilisp.c:622: return with value
	LDD	4,U		variable val, declared at minilisp.c:619
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION read_quote(): defined at minilisp.c:610
_read_quote	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-14,S	
* Line minilisp.c:611: assignment: =
	LDD	4,U		variable root, declared at minilisp.c:610
* optim: remove16BitStackOperation
	LEAX	-12,U		index 0 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:611: for init
* Line minilisp.c:611: init of variable i
	CLRA
	LDB	#$01		1
	STD	-14,U		variable i
	BRA	L01142		jump to for condition
L01141	EQU	*
* Line minilisp.c:611: for body
* Line minilisp.c:611: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LEAX	-12,U		address of array root_ADD_ROOT_
	LDD	-14,U		variable i
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	#0		optim: optimizeStackOperations1
	STD	,X	
* Useless label removed
* Line minilisp.c:611: for increment(s)
	LDD	-14,U	
	ADDD	#1	
	STD	-14,U	
L01142	EQU	*
* Line minilisp.c:611: for condition
	LDD	-14,U		variable i
	CMPD	#$02	
	BLE	L01141	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:611: assignment: =
	LDD	#$FFFF		constant expression: 65535 decimal
* optim: remove16BitStackOperation
	LEAX	-6,U		index 3 in array root_ADD_ROOT_[]
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:611: assignment: =
	LEAX	-12,U		address of array root_ADD_ROOT_
* optim: optimizeTfrOp
	STX	4,U		optim: optimizeTfrOp
* Line minilisp.c:611: init of variable sym
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-4,U		variable sym
* Line minilisp.c:611: init of variable tmp
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A	
* optim: removeUselessLeax
	TFR	X,D		as r-value
	ADDD	,S++	
	STD	-2,U		variable tmp
* Line minilisp.c:612: assignment: =
* Line minilisp.c:612: function call: intern()
	LEAX	S00232,PCR	"QUOTE"
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:610
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_intern	
	LEAS	4,S	
* optim: pushDLoadXLoadD
	LDX	-4,U		indirection of variable sym
* 
	STD	,X	
* Line minilisp.c:613: assignment: =
* Line minilisp.c:613: function call: read_expr()
	LDD	4,U		variable root, declared at minilisp.c:610
	PSHS	B,A		argument 1 of read_expr()
	LBSR	_read_expr
	LEAS	2,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable tmp
* 
	STD	,X	
* Line minilisp.c:614: assignment: =
* Line minilisp.c:614: function call: cons()
	LEAX	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimizePshsOps
	LDD	-2,U		variable tmp, declared at minilisp.c:611
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:610
	PSHS	B,A		argument 1 of cons()
	LBSR	_cons	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable tmp
* 
	STD	,X	
* Line minilisp.c:615: assignment: =
* Line minilisp.c:615: function call: cons()
	LDY	-2,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LDX	-4,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:610
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_cons	
	LEAS	6,S	
* optim: pushDLoadXLoadD
	LDX	-2,U		indirection of variable tmp
* 
	STD	,X	
* Line minilisp.c:616: return with value
* optim: optimizeIndexedX
	LDD	[-2,U]		optim: optimizeIndexedX
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION read_symbol(): defined at minilisp.c:625
_read_symbol	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-203,S	
* Line minilisp.c:627: assignment: =
	LDB	7,U		variable c, declared at minilisp.c:625
* optim: stripExtraPushPullB
	LEAX	-203,U		index 0 in array buf[]
* optim: stripExtraPushPullB
	STB	,X	
* Line minilisp.c:628: init of variable len
	CLRA
	LDB	#$01		1
	STD	-2,U		variable len
* Line minilisp.c:629: while
L01146	EQU	*		while condition at minilisp.c:629
* Line minilisp.c:629: function call: isalnum()
* Line minilisp.c:629: function call: peek()
	LBSR	_peek	
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of isalnum()
	LBSR	_isalnum
	LEAS	2,S	
	TSTB
	BNE	L01145	
* optim: branchToNextLocation
* Useless label removed
* Line minilisp.c:629: function call: strchr()
* Line minilisp.c:629: function call: peek()
	LBSR	_peek	
	SEX			promoting byte argument to word
	PSHS	B,A		argument 2 of strchr()
	LEAX	G00202+0,PCR	address of array symbol_chars
	PSHS	X		argument 1 of strchr()
	LBSR	_strchr	
	LEAS	4,S	
	ADDD	#0	
	LBEQ	L01147	
* optim: condBranchOverUncondBranch
L01145	EQU	*		while body
* Line minilisp.c:630: if
* optim: optimize16BitStackOps1
* optim: optimize16BitStackOps1
	CLRA
	LDB	#$C8		decimal 200 signed
	CMPD	-2,U		optim: optimize16BitStackOps1
	BGT	L01150	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:631: function call: printf()
	LEAX	S00233,PCR	"SYMBOL NAME TOO LONG\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line minilisp.c:631: function call: longjmp()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of longjmp()
	LEAX	G00186+0,PCR	variable jmpbuf, declared at minilisp.c:31
	PSHS	X		argument 1 of longjmp()
	LBSR	_longjmp
	LEAS	4,S	
L01150	EQU	*		else
* Useless label removed
* Line minilisp.c:632: assignment: =
* Line minilisp.c:632: function call: getchar()
	LBSR	_getchar
	PSHS	B	
	LEAX	-203,U		address of array buf
	PSHS	X		preserve array address, then eval array index
	LEAX	-2,U		variable len, declared at minilisp.c:628
	LDD	,X	
	ADDD	#1	
	STD	,X	
	SUBD	#1		post increment yields initial value
	PULS	X		retrieve array address
	LEAX	D,X		add byte offset
	LDB	,S+	
	STB	,X	
	LBRA	L01146		go to while condition
L01147	EQU	*		after end of while starting at minilisp.c:629
* Line minilisp.c:634: assignment: =
	CLRA
	CLRB
	PSHS	B	
	LEAX	-203,U		address of array buf
	LDD	-2,U		variable len
	LEAX	D,X		add byte offset
	LDB	,S+	
	STB	,X	
* Line minilisp.c:635: return with value
* Line minilisp.c:635: function call: intern()
	LEAX	-203,U		address of array buf
* optim: optimizePshsOps
	LDD	4,U		variable root, declared at minilisp.c:625
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_intern	
	LEAS	4,S	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION reverse(): defined at minilisp.c:550
_reverse	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-4,S	
* Line minilisp.c:551: init of variable ret
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
	STD	-2,U		variable ret
* Line minilisp.c:552: while
L01153	EQU	*		while condition at minilisp.c:552
	LDD	G00188+0,PCR	variable Nil, declared at minilisp.c:106
* optim: optimize16BitCompares
* optim: optimize16BitCompares
	CMPD	4,U		optim: optimize16BitCompares
	BEQ	L01154		optim: optimize16BitCompares
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:553: init of variable head
	LDD	4,U		variable p, declared at minilisp.c:550
	STD	-4,U		variable head
* Line minilisp.c:554: assignment: =
	LDX	4,U		variable p
	LEAX	4,X		member val of Obj
	LDD	2,X		member cdr of cell
	STD	4,U	
* Line minilisp.c:555: assignment: =
	LDD	-2,U		variable ret, declared at minilisp.c:551
* optim: remove16BitStackOperation
	LDX	-4,U		variable head
	LEAX	4,X		member val of Obj
	LEAX	2,X		member cdr of cell
* optim: remove16BitStackOperation
	STD	,X	
* Line minilisp.c:556: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-4,U	
	STD	-2,U	
	BRA	L01153		go to while condition
L01154	EQU	*		after end of while starting at minilisp.c:552
* Line minilisp.c:558: return with value
	LDD	-2,U		variable ret, declared at minilisp.c:551
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION rewind(): defined at /usr/local/share/cmoc/disk.h:184
_rewind	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line /usr/local/share/cmoc/disk.h:186: if
	LDD	4,U		variable fd, declared at /usr/local/share/cmoc/disk.h:184
* optim: loadCmpZeroBeqOrBne
	BNE	L01156	
* optim: condBranchOverUncondBranch
* Useless label removed
	LBRA	L00079		return (/usr/local/share/cmoc/disk.h:187)
L01156	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:189: init of variable fat
* Line /usr/local/share/cmoc/disk.h:189: function call: updateFAT()
	LBSR	_updateFAT
	STD	-2,U		variable fat
* Line /usr/local/share/cmoc/disk.h:190: if
* optim: storeLoad
	ADDD	#0	
	BNE	L01159	
* optim: branchToNextLocation
* Useless label removed
	LBRA	L00079		return (/usr/local/share/cmoc/disk.h:191)
L01159	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:193: assignment: =
	LDX	4,U		variable fd
	LDB	1,X		member firstGran of FileDesc
* optim: stripExtraPushPullB
* optim: removeUselessLdx
	LEAX	8,X		member curGran of FileDesc
* optim: stripExtraPushPullB
	STB	,X	
* Line /usr/local/share/cmoc/disk.h:194: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
* optim: stripExtraPushPullB
	LDX	4,U		variable fd
	LEAX	9,X		member curSec of FileDesc
* optim: stripExtraPushPullB
	STB	,X	
* Line /usr/local/share/cmoc/disk.h:195: assignment: =
* Line /usr/local/share/cmoc/disk.h:195: function call: getGranuleLength()
	LDX	4,U		variable fd
	LDD	2,X		member numBytesLastSector of FileDesc
	PSHS	B,A		argument 3 of getGranuleLength()
* optim: removeUselessLdx
	LDB	1,X		member firstGran of FileDesc
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of getGranuleLength()
	LDD	-2,U		variable fat, declared at /usr/local/share/cmoc/disk.h:189
	PSHS	B,A		argument 1 of getGranuleLength()
	LBSR	_getGranuleLength
	LEAS	6,S	
	PSHS	B,A	
	LDX	4,U		variable fd
	LEAX	10,X		member curGranLen of FileDesc
	LDD	,S++	
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:196: assignment: =
	CLRA
	CLRB
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable fd
	LEAX	12,X		member offset of FileDesc
	LDB	#0		optim: removeAndOrMulAddSub
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:197: assignment: =
* optim: removeClr
* optim: removeClr
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable fd
	LEAX	12,X		member offset of FileDesc
	LEAX	2,X		index 1 in array of 2-byte elements
	LDB	#0		optim: removeAndOrMulAddSub
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:198: assignment: =
* optim: removeClr
* optim: removeClr
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable fd
	LEAX	16,X		member secOffset of FileDesc
	LDB	#0		optim: removeAndOrMulAddSub
	STD	,X	
* Line /usr/local/share/cmoc/disk.h:199: assignment: =
* optim: removeClr
* optim: removeClr
* PSHS B,A optim: optimizeStackOperations1
	LDX	4,U		variable fd
	LEAX	274,X		member curSectorAvailBytes of FileDesc
	LDB	#0		optim: removeAndOrMulAddSub
	STD	,X	
L00079	EQU	*		end of rewind()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION roundup(): defined at minilisp.c:192
_roundup	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:193: return with value
	LDD	6,U		variable size
	ADDD	#$FFFF		65535
	COMA
	COMB
	PSHS	B,A	
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A	
* optim: optimize16BitStackOps2
* optim: optimize16BitStackOps2
	LDD	4,U		variable var, declared at minilisp.c:192
	ADDD	6,U		optim: optimize16BitStackOps2
	SUBD	,S++	
	ANDA	,S+	
	ANDB	,S+	
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION screen2ascii(): defined at minilisp.c:403
_screen2ascii	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:404: if
	LDB	5,U		variable c
	CMPB	#$01	
	BLT	L01162	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	5,U		variable c
	CMPB	#$1A	
	BGT	L01162	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:405: return with value
	LDB	5,U	
	SEX
	ADDD	#$60		96
	BRA	L00116		return (minilisp.c:405)
L01162	EQU	*		else
* Useless label removed
* Line minilisp.c:407: if
	LDB	5,U		variable c
	CMPB	#$60	
	BLT	L01166	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	5,U		variable c
	CMPB	#$7F	
	BGT	L01166	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:408: return with value
	LDB	5,U	
	SEX
	ADDD	#$FFC0		65472
	BRA	L00116		return (minilisp.c:408)
L01166	EQU	*		else
* Useless label removed
* Line minilisp.c:410: return with value
	LDB	5,U		variable c, declared at minilisp.c:403
* optim: branchToNextLocation
L00116	EQU	*		end of screen2ascii()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION setjmp(): defined at setjmp.c:7
_setjmp	EQU	*
* Inline assembly:


    ldx 2,s
    ldd ,s
    std ,x
    sts 2,x
    stu 4,x
    clra
    clrb
    rts
  

* End of inline assembly.
* Useless label removed
	RTS
* END FUNCTION


*******************************************************************************

* FUNCTION skip_line(): defined at minilisp.c:562
_skip_line	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
L01169	EQU	*
* Line minilisp.c:563: for body
* Line minilisp.c:564: init of variable c
* Line minilisp.c:564: function call: getchar()
	LBSR	_getchar
	CLRA
	STD	-2,U		variable c
* Line minilisp.c:565: if
* optim: storeLoad
	TSTB			optim: removeAndOrMulAddSub
	BEQ	L01173	
* optim: branchToNextLocation
* Useless label removed
	LDD	-2,U		variable c
	CMPD	#$0A	
	BNE	L01174	
* optim: condBranchOverUncondBranch
L01173	EQU	*		then
	BRA	L00125		return (minilisp.c:566)
L01174	EQU	*		else
* Useless label removed
* Line minilisp.c:567: if
	LDD	-2,U		variable c
	CMPD	#$0D	
	BNE	L01178	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:568: if
	LDB	#$0A		optim: lddToLDB
	SEX			promotion of binary operand
	PSHS	B,A	
* Line minilisp.c:568: function call: peek()
	LBSR	_peek	
	SEX			promotion of binary operand
	LEAS	1,S		disregard MSB
	CMPB	,S+		compare with LSB
	BNE	L01181	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:569: function call: getchar()
	LBSR	_getchar
L01181	EQU	*		else
* Useless label removed
	BRA	L00125		return (minilisp.c:570)
L01178	EQU	*		else
* Useless label removed
* Useless label removed
	BRA	L01169	
* Useless label removed
L00125	EQU	*		end of skip_line()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION ungetc(): defined at minilisp.c:513
_ungetc	EQU	*
	PSHS	U	
	LEAU	,S	
* Line minilisp.c:514: if
	LDB	G00207+0,PCR	variable doing_load, declared at minilisp.c:429
* optim: loadCmpZeroBeqOrBne
	BEQ	L01184	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line minilisp.c:515: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDB	5,U	
	STB	G00210+0,PCR
* Line minilisp.c:516: assignment: =
	CLRA
* optim: stripConsecutiveLoadsToSameReg
	LDB	#$01	
	STB	G00209+0,PCR
	BRA	L00119		return (minilisp.c:517)
L01184	EQU	*		else
* Useless label removed
* Line minilisp.c:520: if
	LEAX	G00203+0,PCR	address of array buffer
	TFR	X,D		as r-value
	PSHS	B,A	
	LDD	G00205+0,PCR	variable start_pos, declared at minilisp.c:427
	CMPD	,S++	
	BHI	L01187	
* optim: condBranchOverUncondBranch
* Useless label removed
	BRA	L00119		return (minilisp.c:521)
L01187	EQU	*		else
* Useless label removed
* Line minilisp.c:523: assignment: =
	CLRA
* optim: stripConsecutiveLoadsToSameReg
	LDB	#$01	
	STB	G00204+0,PCR
	LEAX	G00205+0,PCR	variable start_pos, declared at minilisp.c:427
	LDD	,X	
	SUBD	#1	
	STD	,X	
* Line minilisp.c:525: assignment: =
* Line minilisp.c:525: function call: ascii2screen()
	LDB	5,U		variable c, declared at minilisp.c:513
	SEX			promoting byte argument to word
	PSHS	B,A		argument 1 of ascii2screen()
	LBSR	_ascii2screen
	LEAS	2,S	
* optim: stripExtraPushPullB
	LDX	G00205+0,PCR	indirection of variable start_pos
* optim: stripExtraPushPullB
	STB	,X	
* optim: branchToNextLocation
L00119	EQU	*		end of ungetc()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION updateFAT(): defined at /usr/local/share/cmoc/disk.h:212
_updateFAT	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-258,S	
* Line /usr/local/share/cmoc/disk.h:214: if
	LDB	G00185+0,PCR	variable fatUpToDate, declared at /usr/local/share/cmoc/disk.h:140
* optim: loadCmpZeroBeqOrBne
	BEQ	L01190	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:215: return with value
	LDD	G00184+0,PCR	variable fatBuffer, declared at /usr/local/share/cmoc/disk.h:139
	LBRA	L00080		return (/usr/local/share/cmoc/disk.h:215)
L01190	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:217: if
	LDD	G00184+0,PCR	variable fatBuffer, declared at /usr/local/share/cmoc/disk.h:139
* optim: loadCmpZeroBeqOrBne
	BNE	L01193	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:219: init of variable p
	LEAX	G00182+0,PCR	address of array disk_buffer
* optim: optimizeTfrOp
	STX	-258,U		optim: optimizeTfrOp
* Line /usr/local/share/cmoc/disk.h:220: if
* LDD #$FFFF optim: optimizeStackOperations1
* PSHS B,A optim: optimizeStackOperations1
	LDD	-258,U		variable p, declared at /usr/local/share/cmoc/disk.h:219
	CMPD	#65535		optim: optimizeStackOperations1
	BNE	L01196	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:222: function call: printf()
	LDB	G00183+0,PCR	variable curDriveNo, declared at /usr/local/share/cmoc/disk.h:138
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of printf()
	LEAX	S00214,PCR	"updateFAT: failed to allocate memory for FAT of drive %u\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
* Line /usr/local/share/cmoc/disk.h:223: return with value
	CLRA
	CLRB
	LBRA	L00080		return (/usr/local/share/cmoc/disk.h:223)
L01196	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:225: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-258,U	
	STD	G00184+0,PCR
L01193	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:229: if
* Line /usr/local/share/cmoc/disk.h:229: function call: readDiskSector()
	LDX	#$02		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$11		decimal 17 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LDB	G00183+0,PCR	variable curDriveNo, declared at /usr/local/share/cmoc/disk.h:138
* optim: removeClr
	PSHS	B,A		argument 2 of readDiskSector()
	LEAX	-256,U		address of array fatSector
	PSHS	X		argument 1 of readDiskSector()
	LBSR	_readDiskSector
	LEAS	8,S	
	TSTB
	BNE	L01199	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:231: function call: printf()
	LDB	G00183+0,PCR	variable curDriveNo, declared at /usr/local/share/cmoc/disk.h:138
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of printf()
	LEAX	S00215,PCR	"updateFAT: failed to read FAT of drive %u\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
* Line /usr/local/share/cmoc/disk.h:232: return with value
	CLRA
	CLRB
	BRA	L00080		return (/usr/local/share/cmoc/disk.h:232)
L01199	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/disk.h:235: function call: memcpy()
	CLRA
	LDB	#$44		decimal 68 signed
	PSHS	B,A		argument 3 of memcpy()
	LEAX	-256,U		address of array fatSector
* optim: optimizePshsOps
	LDD	G00184+0,PCR	variable fatBuffer, declared at /usr/local/share/cmoc/disk.h:139
	PSHS	X,B,A		optim: optimizePshsOps
	LBSR	_memcpy	
	LEAS	6,S	
* Line /usr/local/share/cmoc/disk.h:236: assignment: =
	CLRA
* optim: stripConsecutiveLoadsToSameReg
	LDB	#$01	
	STB	G00185+0,PCR
* Line /usr/local/share/cmoc/disk.h:237: return with value
	LDD	G00184+0,PCR	variable fatBuffer, declared at /usr/local/share/cmoc/disk.h:139
* optim: branchToNextLocation
L00080	EQU	*		end of updateFAT()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION waitkey(): defined at /usr/local/share/cmoc/coco.h:368
_waitkey	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-1,S	
* Line /usr/local/share/cmoc/coco.h:371: if
	LDB	5,U		variable blinkCursor, declared at /usr/local/share/cmoc/coco.h:368
* optim: loadCmpZeroBeqOrBne
	LBEQ	L01202	
* optim: condBranchOverUncondBranch
* Useless label removed
* Inline assembly:


            jsr $A1B1
            sta -1,U
        

* End of inline assembly.
* Line /usr/local/share/cmoc/coco.h:378: return with value
	LDB	-1,U		variable key, declared at /usr/local/share/cmoc/coco.h:370
	BRA	L00054		return (/usr/local/share/cmoc/coco.h:378)
L01202	EQU	*		else
* Useless label removed
L01204	EQU	*
* Line /usr/local/share/cmoc/coco.h:381: for body
* Line /usr/local/share/cmoc/coco.h:383: assignment: =
* Line /usr/local/share/cmoc/coco.h:383: function call: inkey()
	LBSR	_inkey	
	STB	-1,U	
* Line /usr/local/share/cmoc/coco.h:384: if
* optim: storeLoad
	TSTB
	BEQ	L01209	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:385: return with value
	LDB	-1,U		variable key, declared at /usr/local/share/cmoc/coco.h:370
	BRA	L00054		return (/usr/local/share/cmoc/coco.h:385)
L01209	EQU	*		else
* Useless label removed
* Useless label removed
	BRA	L01204	
* Useless label removed
L00054	EQU	*		end of waitkey()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION


*******************************************************************************

* FUNCTION width(): defined at /usr/local/share/cmoc/coco.h:145
_width	EQU	*
	PSHS	U	
	LEAU	,S	
* Line /usr/local/share/cmoc/coco.h:147: if
	LDB	G00179+0,PCR	variable isCoCo3, declared at /usr/local/share/cmoc/coco.h:38
* optim: loadCmpZeroBeqOrBne
	BNE	L01212	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:148: return with value
	CLRA
	CLRB
	LBRA	L00044		return (/usr/local/share/cmoc/coco.h:148)
L01212	EQU	*		else
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:150: if
	LDB	5,U		variable columns
	CMPB	#$20	
	BEQ	L01215	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	5,U		variable columns
	CMPB	#$28	
	BEQ	L01215	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	5,U		variable columns
	CMPB	#$50	
	BEQ	L01215	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:151: return with value
	CLRA
	CLRB
	BRA	L00044		return (/usr/local/share/cmoc/coco.h:151)
L01215	EQU	*		else
* Useless label removed
	PSHS	U,Y		/usr/local/share/cmoc/coco.h:153: [inline asm]
	LDB	5,U		/usr/local/share/cmoc/coco.h:154: [inline asm] re: variable columns
	JSR	$F643		/usr/local/share/cmoc/coco.h:155: [inline asm]
	PULS	Y,U		/usr/local/share/cmoc/coco.h:156: [inline asm]
* Line /usr/local/share/cmoc/coco.h:158: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDB	5,U	
	STB	G00180+0,PCR
* Line /usr/local/share/cmoc/coco.h:159: assignment: =
	LDB	5,U		variable columns
	CMPB	#$20	
	BEQ	L01219		if true
	CLRB
	BRA	L01220		false
L01219	EQU	*
	LDB	#1	
L01220	EQU	*
	TSTB
	BEQ	L01221		if conditional expression is false
	CLRA
	LDB	#$10		decimal 16 signed
	BRA	L01222		end of true expression of conditional
L01221	EQU	*
	CLRA
	LDB	#$18		decimal 24 signed
L01222	EQU	*
	STB	G00181+0,PCR
* Line /usr/local/share/cmoc/coco.h:161: return with value
	CLRA
	LDB	#$01		decimal 1 signed
* optim: branchToNextLocation
L00044	EQU	*		end of width()
	LEAS	,U	
	PULS	U,PC	
* END FUNCTION
functions_end	EQU	*
string_literals_start	EQU	*


*******************************************************************************

* STRING LITERALS
S00211	EQU	*
	FCC	"***ASSERT FAILED: %s:%u: %s"
	FCB	$0A	
	FCB	0	
S00212	EQU	*
	FCC	"/usr/local/share/cmoc/disk.h"
	FCB	0	
S00213	EQU	*
	FCC	"fd->curSector != 0"
	FCB	0	
S00214	EQU	*
	FCC	"updateFAT: failed to allocate memory for FAT of drive %u"
	FCB	$0A	
	FCB	0	
S00215	EQU	*
	FCC	"updateFAT: failed to read FAT of drive %u"
	FCB	$0A	
	FCB	0	
S00216	EQU	*
	FCC	"offsetInLastGranule < GRANULE_SIZE"
	FCB	0	
S00217	EQU	*
	FCC	"gran < 0xC0"
	FCB	0	
S00218	EQU	*
	FCC	"gran >= 0 && gran < MAX_NUM_GRANULES"
	FCB	0	
S00219	EQU	*
	FCC	"fd->curSec >= 1 && fd->curSec <= 9"
	FCB	0	
S00220	EQU	*
	FCC	"fd->secOffset <= fd->curSectorAvailBytes"
	FCB	0	
S00221	EQU	*
	FCC	"MEMORY EXHAUSTED %x < %x"
	FCB	$0A	
	FCB	0	
S00222	EQU	*
	FCC	"minilisp.c"
	FCB	0	
S00223	EQU	*
	FCC	"!gc_running"
	FCB	0	
S00224	EQU	*
	FCC	"BUG: COPY: UNKNOWN TYPE%d"
	FCB	$0A	
	FCB	0	
S00225	EQU	*
	FCC	"GC: %x/%x"
	FCB	$0A	
	FCB	0	
S00226	EQU	*
	FCC	"type == TFUNCTION || type == TMACRO"
	FCB	0	
S00227	EQU	*
	FCC	"~!@#$%^&*-_=+:/?<>"
	FCB	0	
S00228	EQU	*
	FCB	$0A	
	FCB	0	
S00229	EQU	*
	FCC	"%c"	
	FCB	0	
S00230	EQU	*
	FCC	"UNCLOSED PARENTHESIS"
	FCB	$0A	
	FCB	0	
S00231	EQU	*
	FCC	"CLOSED PARENTHESIS EXPECTED AFTER DOT"
	FCB	$0A	
	FCB	0	
S00232	EQU	*
	FCC	"QUOTE"	
	FCB	0	
S00233	EQU	*
	FCC	"SYMBOL NAME TOO LONG"
	FCB	$0A	
	FCB	0	
S00234	EQU	*
	FCC	"DON'T KNOW HOW TO HANDLE %c"
	FCB	0	
S00235	EQU	*
	FCC	"("	
	FCB	0	
S00236	EQU	*
	FCC	" . "	
	FCB	0	
S00237	EQU	*
	FCC	" "	
	FCB	0	
S00238	EQU	*
	FCC	")"	
	FCB	0	
S00239	EQU	*
	FCC	"%d"	
	FCB	0	
S00240	EQU	*
	FCC	"%s"	
	FCB	0	
S00241	EQU	*
	FCC	"<PRIMITIVE>"
	FCB	0	
S00242	EQU	*
	FCC	"<FUNCTION>"
	FCB	0	
S00243	EQU	*
	FCC	"<MACRO>"
	FCB	0	
S00244	EQU	*
	FCC	"<MOVED>"
	FCB	0	
S00245	EQU	*
	FCC	"T"	
	FCB	0	
S00246	EQU	*
	FCC	"()"	
	FCB	0	
S00247	EQU	*
	FCC	"BUG: PRINT: UNKNOWN TAG TYPE: %d"
	FCB	$0A	
	FCB	0	
S00248	EQU	*
	FCC	"CANNOT APPLY FUNCTION: NUMBER OF ARGUMENTS DO NOT MATCH"
	FCB	$0A	
	FCB	0	
S00249	EQU	*
	FCC	"ARGUMENT MUST BE A LIST"
	FCB	$0A	
	FCB	0	
S00250	EQU	*
	FCC	"NOT SUPPORTED"
	FCB	$0A	
	FCB	0	
S00251	EQU	*
	FCC	"UNDEFINED SYMBOL: %s"
	FCB	$0A	
	FCB	0	
S00252	EQU	*
	FCC	"THE HEAD OF A LIST MUST BE A FUNCTION"
	FCB	$0A	
	FCB	0	
S00253	EQU	*
	FCC	"BUG: EVAL: KNOWN TAG TYPE: %d"
	FCB	$0A	
	FCB	0	
S00254	EQU	*
	FCC	"MALFORMED QUOTE"
	FCB	$0A	
	FCB	0	
S00255	EQU	*
	FCC	"MALFORMED CONS"
	FCB	$0A	
	FCB	0	
S00256	EQU	*
	FCC	"MALFORMED CAR"
	FCB	$0A	
	FCB	0	
S00257	EQU	*
	FCC	"MALFORMED CDR"
	FCB	$0A	
	FCB	0	
S00258	EQU	*
	FCC	"MALFORMED SETQ"
	FCB	$0A	
	FCB	0	
S00259	EQU	*
	FCC	"UNBOUND VARIABLE %s"
	FCB	$0A	
	FCB	0	
S00260	EQU	*
	FCC	"MALFORMED SETCAR"
	FCB	$0A	
	FCB	0	
S00261	EQU	*
	FCC	"MALFORMED WHILE"
	FCB	$0A	
	FCB	0	
S00262	EQU	*
	FCC	"+ TAKES ONLY NUMBERS"
	FCB	$0A	
	FCB	0	
S00263	EQU	*
	FCC	"* TAKES ONLY NUMBERS"
	FCB	$0A	
	FCB	0	
S00264	EQU	*
	FCC	"- TAKES ONLY NUMBERS"
	FCB	$0A	
	FCB	0	
S00265	EQU	*
	FCC	"MALFORMED <"
	FCB	$0A	
	FCB	0	
S00266	EQU	*
	FCC	"< TAKES ONLY NUMBERS"
	FCB	$0A	
	FCB	0	
S00267	EQU	*
	FCC	"MALFORMED LAMBDA"
	FCB	$0A	
	FCB	0	
S00268	EQU	*
	FCC	"PARAMETER MUST BE A SYMBOL"
	FCB	$0A	
	FCB	0	
S00269	EQU	*
	FCC	"MALFORMED DEFUN"
	FCB	$0A	
	FCB	0	
S00270	EQU	*
	FCC	"MALFORMED DEFINE"
	FCB	$0A	
	FCB	0	
S00271	EQU	*
	FCC	"MALFORMED MACROEXPAND"
	FCB	$0A	
	FCB	0	
S00272	EQU	*
	FCC	"MALFORMED IF"
	FCB	$0A	
	FCB	0	
S00273	EQU	*
	FCC	"MALFORMED ="
	FCB	$0A	
	FCB	0	
S00274	EQU	*
	FCC	"= ONLY TAKES NUMBERS"
	FCB	$0A	
	FCB	0	
S00275	EQU	*
	FCC	"< ONLY TAKES NUMBERS"
	FCB	$0A	
	FCB	0	
S00276	EQU	*
	FCC	"MALFORMED >"
	FCB	$0A	
	FCB	0	
S00277	EQU	*
	FCC	"> ONLY TAKES NUMBERS"
	FCB	$0A	
	FCB	0	
S00278	EQU	*
	FCC	"MALFORMED <="
	FCB	$0A	
	FCB	0	
S00279	EQU	*
	FCC	"<= ONLY TAKES NUMBERS"
	FCB	$0A	
	FCB	0	
S00280	EQU	*
	FCC	"MALFORMED >="
	FCB	$0A	
	FCB	0	
S00281	EQU	*
	FCC	">= ONLY TAKES NUMBERS"
	FCB	$0A	
	FCB	0	
S00282	EQU	*
	FCC	"MALFORMED EQ"
	FCB	$0A	
	FCB	0	
S00283	EQU	*
	FCC	"MALFORMED LOAD"
	FCB	$0A	
	FCB	0	
S00284	EQU	*
	FCC	".LSP"	
	FCB	0	
S00285	EQU	*
	FCC	"CONS"	
	FCB	0	
S00286	EQU	*
	FCC	"CAR"	
	FCB	0	
S00287	EQU	*
	FCC	"CDR"	
	FCB	0	
S00288	EQU	*
	FCC	"SETQ"	
	FCB	0	
S00289	EQU	*
	FCC	"SETCAR"
	FCB	0	
S00290	EQU	*
	FCC	"WHILE"	
	FCB	0	
S00291	EQU	*
	FCC	"GENSYM"
	FCB	0	
S00292	EQU	*
	FCC	"+"	
	FCB	0	
S00293	EQU	*
	FCC	"*"	
	FCB	0	
S00294	EQU	*
	FCC	"-"	
	FCB	0	
S00295	EQU	*
	FCC	"<"	
	FCB	0	
S00296	EQU	*
	FCC	"DEFINE"
	FCB	0	
S00297	EQU	*
	FCC	"DEFUN"	
	FCB	0	
S00298	EQU	*
	FCC	"DEFMACRO"
	FCB	0	
S00299	EQU	*
	FCC	"MACROEXPAND"
	FCB	0	
S00300	EQU	*
	FCC	"LAMBDA"
	FCB	0	
S00301	EQU	*
	FCC	"IF"	
	FCB	0	
S00302	EQU	*
	FCC	"="	
	FCB	0	
S00303	EQU	*
	FCC	">"	
	FCB	0	
S00304	EQU	*
	FCC	"<="	
	FCB	0	
S00305	EQU	*
	FCC	">="	
	FCB	0	
S00306	EQU	*
	FCC	"EQ"	
	FCB	0	
S00307	EQU	*
	FCC	"PRINTLN"
	FCB	0	
S00308	EQU	*
	FCC	"LOAD"	
	FCB	0	
S00309	EQU	*
	FCC	"COLOR COMPUTER MINILISP"
	FCB	$0A	
	FCB	0	
S00310	EQU	*
	FCC	"ORIGINAL BY RUI UEYAMA"
	FCB	$0A	
	FCB	0	
S00311	EQU	*
	FCC	"COCO PORT: JAMIE CHO"
	FCB	$0A	
	FCB	$0A	
	FCB	0	
S00312	EQU	*
	FCC	"PRESS <BREAK> TO EVAL COMMANDS"
	FCB	$0A	
	FCB	$0A	
	FCB	0	
S00313	EQU	*
	FCC	"STRAY CLOSE PARENTHESIS"
	FCB	$0A	
	FCB	0	
S00314	EQU	*
	FCC	"STRAY DOT"
	FCB	$0A	
	FCB	0	
string_literals_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES
writable_globals_start	EQU	*


*******************************************************************************

* WRITABLE GLOBAL VARIABLES
* Globals with static initializers
G00202	EQU	*		symbol_chars: char[]
	FCC	"~!@#$%^&*-_=+:/?<>"
	FCB	0	
* Uninitialized globals
G00179	EQU	*
	RMB	1		isCoCo3
G00180	EQU	*
	RMB	1		textScreenWidth
G00181	EQU	*
	RMB	1		textScreenHeight
G00182	EQU	*
	RMB	68		disk_buffer
G00183	EQU	*
	RMB	1		curDriveNo
G00184	EQU	*
	RMB	2		fatBuffer
G00185	EQU	*
	RMB	1		fatUpToDate
G00186	EQU	*
	RMB	6		jmpbuf
G00187	EQU	*
	RMB	2		True
G00188	EQU	*
	RMB	2		Nil
G00189	EQU	*
	RMB	2		Dot
G00190	EQU	*
	RMB	2		Cparen
G00191	EQU	*
	RMB	2		Symbols
G00192	EQU	*
	RMB	4224		memory1
G00193	EQU	*
	RMB	4224		memory2
G00194	EQU	*
	RMB	2		memory
G00195	EQU	*
	RMB	2		from_space
G00196	EQU	*
	RMB	2		mem_nused
G00197	EQU	*
	RMB	1		gc_running
G00198	EQU	*
	RMB	1		debug_gc
G00199	EQU	*
	RMB	1		always_gc
G00200	EQU	*
	RMB	2		scan1
G00201	EQU	*
	RMB	2		scan2
G00203	EQU	*
	RMB	512		buffer
G00204	EQU	*
	RMB	1		has_data
G00205	EQU	*
	RMB	2		start_pos
G00206	EQU	*
	RMB	2		end_pos
G00207	EQU	*
	RMB	1		doing_load
G00208	EQU	*
	RMB	276		fd
G00209	EQU	*
	RMB	1		has_file_data
G00210	EQU	*
	RMB	1		file_data


*******************************************************************************

#include "stdlib-data.inc"
writable_globals_end	EQU	*


*******************************************************************************

#include "stdlib.inc"


*******************************************************************************

* Initialize global variables.
INITGL	EQU	*
* Line /usr/local/share/cmoc/coco.h:38: init of variable isCoCo3
	CLRB
	STB	G00179+0,PCR	variable isCoCo3
* Line /usr/local/share/cmoc/coco.h:139: init of variable textScreenWidth
	LDB	#$20		32
	STB	G00180+0,PCR	variable textScreenWidth
* Line /usr/local/share/cmoc/coco.h:140: init of variable textScreenHeight
	LDB	#$10		16
	STB	G00181+0,PCR	variable textScreenHeight
* Line /usr/local/share/cmoc/disk.h:138: init of variable curDriveNo
	CLR	G00183+0,PCR	variable curDriveNo
* Line /usr/local/share/cmoc/disk.h:139: init of variable fatBuffer
	CLRA
	CLRB
	STD	G00184+0,PCR	variable fatBuffer
* Line /usr/local/share/cmoc/disk.h:140: init of variable fatUpToDate
* optim: removeClr
	STB	G00185+0,PCR	variable fatUpToDate
* Line minilisp.c:130: init of variable mem_nused
* optim: removeClr
* optim: removeClr
	STD	G00196+0,PCR	variable mem_nused
* Line minilisp.c:133: init of variable gc_running
* optim: removeClr
	STB	G00197+0,PCR	variable gc_running
* Line minilisp.c:134: init of variable debug_gc
* optim: stripExtraClrA_B
	STB	G00198+0,PCR	variable debug_gc
* Line minilisp.c:135: init of variable always_gc
* optim: stripExtraClrA_B
	STB	G00199+0,PCR	variable always_gc
* Line minilisp.c:426: init of variable has_data
* optim: stripExtraClrA_B
	STB	G00204+0,PCR	variable has_data
* Line minilisp.c:427: init of variable start_pos
	LEAX	G00203+0,PCR	address of array buffer
* optim: optimizeTfrOp
	STX	G00205+0,PCR	optim: optimizeTfrOp
* Line minilisp.c:428: init of variable end_pos
	LEAX	G00203+0,PCR	address of array buffer
* optim: optimizeTfrOp
	STX	G00206+0,PCR	optim: optimizeTfrOp
* Line minilisp.c:429: init of variable doing_load
* optim: removeClr
	STB	G00207+0,PCR	variable doing_load
* Line minilisp.c:431: init of variable has_file_data
* optim: stripExtraClrA_B
	STB	G00209+0,PCR	variable has_file_data
	RTS			end of global variable initialization


*******************************************************************************

program_end	EQU	*


*******************************************************************************

* WRITABLE DATA SECTION


*******************************************************************************

	END
